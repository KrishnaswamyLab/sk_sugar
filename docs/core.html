---

title: core


keywords: fastai
sidebar: home_sidebar

summary: "API details. See docs for now."
description: "API details. See docs for now."
nb_path: "00_core.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 00_core.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="validate_sigma" class="doc_header"><code>validate_sigma</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L41" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>validate_sigma</code>(<strong><code>sigma</code></strong>:<code>~SigmaType</code>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"knn"`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>None</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">VALID_SIGMAS</span> <span class="o">=</span> <span class="s1">&#39;minmax median std knn&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="n">SigmaType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;SigmaType&#39;</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;minimax&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;knn&quot;</span><span class="p">],</span> <span class="n">Callable</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">validate_sigma</span><span class="p">(</span>
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="p">,</span> 
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;knn&quot;`.</span>
<span class="sd">            </span>
<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">is_known</span> <span class="o">=</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">VALID_SIGMAS</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;sigma (</span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s1">) is </span><span class="si">{</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">is_known</span> <span class="k">else</span> <span class="s2">&quot;not &quot;</span><span class="si">}</span><span class="s1">known or callable.</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="sa">f</span><span class="s1">&#39;known sigmas include </span><span class="si">{</span><span class="n">VALID_SIGMAS</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_known</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="gauss_kernel" class="doc_header"><code>gauss_kernel</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L80" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>gauss_kernel</code>(<strong><code>data1</code></strong>:<code>ndarray</code>, <strong><code>data2</code></strong>:<code>ndarray</code>, <strong><code>sigma</code></strong>:<code>~SigmaType</code>=<em><code>'knn'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Validated via points.csv file

- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/gauss_kernel.m

- compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927

- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data1 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

data2 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"knn"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian
    kernel.

fac (int): Rescale kernel bandwidth. Defaults to `1`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>K (np.ndarray): kernel over data1, data2

sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">gauss_kernel</span><span class="p">(</span>
    <span class="n">data1</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">data2</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Validated via points.csv file</span>
<span class="sd">        </span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/gauss_kernel.m</span>

<span class="sd">        - compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>
<span class="sd">        </span>
<span class="sd">        - `a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data1 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        data2 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;knn&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        fac (int): Rescale kernel bandwidth. Defaults to `1`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        K (np.ndarray): kernel over data1, data2</span>

<span class="sd">        sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">validate_sigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
    
    <span class="n">D</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># print(np.round(D, 4)[:5, :5])</span>
    
    <span class="c1"># NOTE: validated with points.csv</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
        <span class="n">min_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">15</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">eps_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">min_dev</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps_val</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>        

    <span class="c1"># NOTE: validated with points.csv</span>
    <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># NOTE: validated with points.csv</span>
    <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;std&#39;</span><span class="p">:</span>
        <span class="c1"># sigma = std(mean(D))</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="c1"># NOTE: validated with points.csv</span>
    <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;knn&#39;</span><span class="p">:</span>
        <span class="n">knn_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>
        <span class="c1"># sigma = knn_dist(k+1,:);</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">knn_dist</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># NOTE: validated with points.csv</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">fac</span>
    
    <span class="c1"># K = bsxfun(@rdivide, D, sigma);</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span> <span class="c1"># K = np.apply_along_axis(np.divide, 0, D, sigma)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    
    <span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    
    <span class="k">return</span> <span class="n">K</span><span class="p">,</span> <span class="n">sigma</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pnts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;points.csv&#39;</span><span class="p">),</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
<span class="n">rnd_pnts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;random_points.csv&#39;</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,)</span><span class="o">.</span><span class="n">values</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">K</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="n">rnd_pnts</span><span class="p">,</span> <span class="s1">&#39;knn&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">K</span><span class="p">[:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="n">sigma</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[0.        , 0.        , 0.00391327, 0.        , 0.        ],
        [0.97112778, 0.36787944, 0.34058866, 0.        , 0.        ],
        [0.        , 0.75845049, 0.89521196, 0.        , 0.        ],
        [0.        , 0.        , 0.00546059, 0.        , 0.        ],
        [0.        , 0.        , 0.        , 0.95346529, 0.        ]]),
 array([0.11821752, 0.24887548, 0.53853001, 0.07115662, 0.15531824,
        0.18688265, 0.13103245, 0.70869515, 0.29084548, 0.77155735,
        0.48030788, 0.0875428 , 0.94569724, 0.60007401, 0.21228984,
        0.35344204, 0.12498315, 0.11855851, 0.14912764, 0.08430752,
        0.21320032, 0.10458859, 0.12634235, 0.14870922, 0.87394288,
        0.48746408, 0.23136904, 0.29808207, 0.1621171 , 0.21642745,
        0.08490285, 0.12895623, 0.1078907 , 0.29769147, 0.26593868,
        0.08384001, 0.09196327, 0.24073227, 0.17551875, 0.05998292,
        0.08504684, 0.28296482, 0.05620995, 0.14385606, 0.15001278,
        0.06294853, 0.2429058 , 0.07863779, 0.15294187, 0.16144378,
        0.08492216, 0.11846428, 0.12218157]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">K</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="n">pnts</span><span class="p">,</span> <span class="s1">&#39;knn&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">K</span><span class="p">[:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[1.        , 0.        , 0.        , 0.7132805 , 0.        ],
        [0.        , 1.        , 0.18393972, 0.        , 0.        ],
        [0.        , 0.18393972, 1.        , 0.        , 0.        ],
        [0.7132805 , 0.        , 0.        , 1.        , 0.        ],
        [0.        , 0.        , 0.        , 0.        , 1.        ]]),
 array([0.09987109, 0.12998326, 0.37973647, 0.07036419, 0.08668946,
        0.14001442, 0.14816215, 0.14001442, 0.09798825, 0.1237121 ]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&lt;AxesSubplot:&gt;</pre>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">data2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># data2=data1</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">VALID_SIGMAS</span><span class="p">:</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sigma=</span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">ax</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAV0AAAEICAYAAAD8yyfzAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/MnkTPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAS1ElEQVR4nO3debAlZXnH8e/PEYyIEffoDAoxuBATSRS04r4yuFFWmSrEaKQwo1XiUmVVRC2NmnIrEzUpMYRCtIzLlAsmo04kViK4ogMRlwExI6JcFscRBBGC3Huf/HHOkOOtO+fc5Zzuc3q+H6vL26f7vP306Dz3maff7k5VIUlqxu3aDkCS9icmXUlqkElXkhpk0pWkBpl0JalBJl1JapBJVwAkeV2SM9uOY1+SPCHJXNtxSOt1+7YD0HSoqre1HYO0P7DSlaQGmXT3Q0lek+TKJL9KcmmSJyd5U5KPDOzzwiQ/SfKLJG9IcnmSp/S3vSnJJ5N8pD/G95I8MMlrk+xOckWSpw2MdVKSS/r7XpbkJWM4h1ckuTjJpr2thySv7h//6iQnDez7oSSnJfl8P4ZvJnnAemOQ1sKku59J8iDgFODoqrozcCxw+ZJ9jgTeDzwfuA9wF2DjkqGeBfwLcFfg28A59P7/tBF4C/DPA/vuBp4J/C5wEvCeJH/aP9b9kvxyyHLiMufwBuBFwOOram+f9/cG4jwZOC3JXQe+9jzgzf14dwFvXcEflzR2Jt39zwJwB+DIJAdU1eVV9aMl+zwX+GxVfbWqfgO8EVj6kI6vVNU5VTUPfBK4J/COqroV2AocluQQgKr6fFX9qHrOA/4DeGx/20+r6pAhy8cGjpkk76b3i+KJVfXzgW23Am+pqlurajtwI/Cgge1nV9W3+vF+FDhqLX940nqZdPczVbULeBXwJmB3kq1J7rtkt/sCVwx85ybgF0v2+dnAzzcDe6pqYWAd4GCAJMclOT/JtUl+CTwduMcawj8E2AK8vaquX7LtF/2EutdNe4/fd82QbVJjTLr7oar6WFU9Brg/vQr2nUt2uRrYtHclyR2Bu6/lWEnuAHwa+Dvg3lV1CLAdSH/7/ZLcOGR5/sBw19FrU3wwyaPXEo/UNqeM7Wf6Pd2NwNeA/6VXlS795fsp4PwkfwZcQK8XmjUe8kB67YyfA/NJjgOeBnwfeu0FVlF1VtW5/UT8mSTPqqpvrjEuqRVWuvufOwDvAPbQ+yf3vYDXDe5QVTuBl9PrzV4N/IrexbBbVnuwqvoV8ArgE/Qq1ROBbWsPH6rqi/QuyG1L8vD1jCU1LT7EXKMkORj4JXBEVf245XCkmWalq2UleVaSg5LciV4/9nssmVomafVMutqX44Gr+ssRwAnlP4ukdbO9IEkNstKVpAZNfMrYrXsu62QpPX/h9rZDGLtbz/5s2yFMxM+/1nYE43ftdQe1HcJEHH3lZ9Y6NfE2q8k5B9zj99d9vNVynq6kbllcGL1Pi0y6krqlFtuOYCiTrqRuWTTpSlJjykpXkhq0MD96nxaZdCV1ixfSJKlBthckqUFeSJOk5nghTZKaZKUrSQ1auLXtCIYy6UrqFtsLktQg2wuS1CArXUlqkJWuJDWnFr2QJknNsdKVpAbZ05WkBvnAG0lq0KxXukkeDBwPbAQKuArYVlWXTDg2SVq9Ke/pDn0Fe5LXAFuBAN8CdvR//niSU4d8b0uSC5JccOaHPz7OeCVpuIX5lS8tGFXpngz8YVX91hyMJO8GdgLvWO5LVXUGcAZ09xXskqbUlFe6o5LuInBf4CdLPr9Pf5skTZWq2b6Q9irgP5P8D3BF/7P7AX8AnDLBuCRpbWa50q2qLyR5IHAMvQtpAeaAHTXtv04k7Z9mffZC9R7Dfn4DsUjS+s1ypStJM8dXsEtSg2a9vSBJM8X2giQ1yKQrSQ2yvSBJDfJCmiQ1aMrbC0MfeCNJM6cWV76MkGRzkkuT7FruIV9J7pLks0m+k2RnkpNGjWmlK6lbxlTpJtkAnAY8lf6duEm2VdXFA7u9DLi4qp6V5J7ApUk+WlW/2de4Jl1J3TK+9sIxwK6qugwgyVZ6zxYfTLoF3DlJgIOBa4GhTWXbC5K6pWrFy+Czv/vLloGRNvL/D/qCXrW7ccnR3gc8hN7LHb4HvLL/6IR9stKV1C3zK5+9MPjs72Vkua8sWT8WuAh4EvAA4ItJvlJVN+zrmFa6krplfBfS5oBDB9Y30atoB50EnF09u4AfAw8eNqhJV1K3LC6ufBluB3BEksOTHAicAGxbss9PgScDJLk38CDgsmGD2l6Q1C01njeEVdV8klOAc4ANwFlVtTPJS/vbTwf+FvhQku/Ra0e8pqr2DBvXpCupW8Z4c0RVbQe2L/ns9IGfrwKetpoxJ5505y/cPnqnGbT41S+3HcLYXX1eN7tNF11/t7ZDGLtrDljuGs/sO3ocg0z5HWlWupI6pRam+01iJl1J3WKlK0kN8tGOktSgxfHMXpgUk66kbrG9IEkN8kKaJDXISleSGmRPV5Ia5OwFSWqQla4kNafs6UpSg5y9IEkNsr0gSQ2yvSBJDbLSlaQGOWVMkhpkpStJzal5Zy9IUnOsdCWpQfZ0JalBU17prvn1r0lOGrJtS5ILklzwge1fW+shJGnVarFWvLRhPZXum4EPLrehqs4AzgC4+Zz3TfevHUndMssX0pJ8d1+bgHuPPxxJWqcpby+MqnTvDRwLXLfk8wBfn0hEkrQeM550PwccXFUXLd2Q5NxJBCRJ61E1w0m3qk4esu3E8YcjSes045WuJM0Wk64kNafmvTlCkpoz3TnXpCupW9q66WGlTLqSusWkK0kNsr0gSc2xvSBJDap5k64kNcf2giQ1Z8qfYb725+lK0lRaXMUyQpLNSS5NsivJqfvY5wlJLkqyM8l5o8a00pXUKeOqdJNsAE4DngrMATuSbKuqiwf2OQR4P7C5qn6a5F6jxjXpSuqUmh/bUMcAu6rqMoAkW4HjgYsH9jkROLuqfgpQVbtHDWp7QVKn1OLKl8FXi/WXLQNDbQSuGFif63826IHAXZOcm+TCJC8cFZ+VrqROWU17YfDVYsvIcl9Zsn574OHAk4E7At9Icn5V/XBfx5x40r317M9O+hCtuPq87v0jYftNd287hInYceCv2w5h7HYv3tR2CBPxynEMUsvlyjWZAw4dWN8EXLXMPnuq6tfAr5N8GXgYsM+k273MIWm/tpr2wgg7gCOSHJ7kQOAEYNuSff4NeGyS2yc5CHgkcMmwQW0vSOqUWhxPpVtV80lOAc4BNgBnVdXOJC/tbz+9qi5J8gXgu/QmoZ1ZVd8fNq5JV1KnLC6Mrb1AVW0Hti/57PQl6+8C3rXSMU26kjpl2u9IM+lK6pRxtRcmxaQrqVOm/A3sJl1J3WKlK0kNGueFtEkw6UrqFCtdSWpQje+OtIkw6UrqFKeMSVKDFq10Jak5thckqUHOXpCkBjl7QZIaZE9XkhpkT1eSGuSzFySpQbYXJKlBi1N+IW3kO9KSPDjJk5McvOTzzZMLS5LWZrGy4qUNQ5NuklfQe/Hay4HvJzl+YPPbhnzvtnfJf/CSufFEKkkrUJUVL20Y1V74K+DhVXVjksOATyU5rKr+geXfCQ/89rvkb3jJsVPe1pbUJbPe091QVTcCVNXlSZ5AL/HenyFJV5LaMu1V3qie7jVJjtq70k/AzwTuAfzRBOOSpDVZWLzdipc2jDrqC4FrBj+oqvmqeiHwuIlFJUlrtLiKpQ1D2wtVtc+rYFX1tfGHI0nrU1Pe+XSerqROWZzypq5JV1KnLFrpSlJzbC9IUoMWTLqS1Jwpfy+lSVdSt5h0JalB9nQlqUFT/mRHk66kbnHKmCQ1aKHtAEYw6UrqlMVY6UpSY6b8LmCTrqRuccqYJDVo2mcvtPMUX0makAWy4mWUJJuTXJpkV5JTh+x3dJKFJM8dNaaVrqROGVelm2QDcBrwVGAO2JFkW1VdvMx+7wTOWcm4E0+6P+/oo84vuv5ubYcwdjsO/HXbIUzEt2++su0Qxm7PLde3HcLUGmNP9xhgV1VdBpBkK3A8cPGS/V4OfBo4eiWD2l6Q1Cm1iiXJliQXDCxbBobaCFwxsD7X/+w2STYCzwFOX2l8thckdcpq2gtVdQZwxj42LzfS0hlp7wVeU1ULWeH8YJOupE4ZY3thDjh0YH0TcNWSfR4BbO0n3HsAT08yX1X/uq9BTbqSOmVhfFPGdgBHJDkcuBI4AThxcIeqOnzvz0k+BHxuWMIFk66kjhlXpVtV80lOoTcrYQNwVlXtTPLS/vYV93EHmXQldco470irqu3A9iWfLZtsq+pFKxnTpCupU3z2giQ1aNpvAzbpSuoUH3gjSQ3yIeaS1CDbC5LUINsLktQgZy9IUoMWpzztmnQldYoX0iSpQfZ0JalBzl6QpAbZ05WkBk13yjXpSuqYme/pJjkGqKrakeRIYDPwg/4jzyRpqixMea079MWUSf4G+Efgn5K8HXgfcDBwapLXD/nebS9723rt3FgDlqRhFlextGFUpftc4CjgDsA1wKaquiHJu4BvAm9d7kuDL3v70UOPne5fO5I6ZdYvpM1X1QJwU5IfVdUNAFV1c5Jpb51I2g9Nd8odnXR/k+SgqroJePjeD5PchenvV0vaD017YhqVdB9XVbcAVNXguRwA/OXEopKkNZr2C2lDk+7ehLvM53uAPROJSJLWYdZ7upI0U6Y75Zp0JXWMla4kNWjWL6RJ0kwpK11Jas5Mz16QpFlje0GSGrRYVrqS1JjpTrkmXUkd45QxSWqQsxckqUHzJl1Jao6VriQ1yCljktSgcsqYJDVnv5+9cO11B036EK245oC0HcLY7V68qe0QJmLPLde3HcLYXXfzjW2HMLW8DViSGjTtle7QV7BL0qypqhUvoyTZnOTSJLuSnLrM9ucn+W5/+XqSh40a00pXUqeMa/ZCkg3AacBTgTlgR5JtVXXxwG4/Bh5fVdclOQ44A3jksHFNupI6ZYzzdI8BdlXVZQBJtgLHA7cl3ar6+sD+5wObRg1qe0FSpyxSK16SbElywcCyZWCojcAVA+tz/c/25WTg30fFZ6UrqVMWauUNhqo6g15LYDnLTVFatoxO8kR6Sfcxo45p0pXUKWNsL8wBhw6sbwKuWrpTkj8GzgSOq6pfjBrUpCupU8b4EPMdwBFJDgeuBE4AThzcIcn9gLOBF1TVD1cyqElXUqeMK+VW1XySU4BzgA3AWVW1M8lL+9tPB94I3B14fxKA+ap6xLBxTbqSOmWcN0dU1XZg+5LPTh/4+cXAi1czpklXUqdM+x1pJl1JnbKa2QttMOlK6hQfYi5JDfJ5upLUIHu6ktQgK11JatDClL8lzaQrqVPGeEfaRJh0JXWKsxckqUHTXumu+nm6ST48iUAkaRxqFf9pw9BKN8m2pR8BT0xyCEBVPXsf39sCbAF47V2O4jl3OmzdgUrSSkx7pTuqvbCJ3qspzqT38J4AjwD+ftiXBh8MvGPjc6b7T0BSp0z7bcCj2guPAC4EXg9cX1XnAjdX1XlVdd6kg5Ok1Zrp9kJVLQLvSfLJ/n//bNR3JKlNNeWV7ooSaFXNAX+e5BnADZMNSZLWrlO3AVfV54HPTygWSVo3bwOWpAZ1qtKVpGm3sNiBnq4kzQpvA5akBtnTlaQG2dOVpAZZ6UpSg7yQJkkNsr0gSQ2yvSBJDZr1RztK0kxxnq4kNchKV5IatNiFRztK0qzwQpokNcikK0kNmu6UC5n23wqrkWRL/6WYndLF8+riOUE3z6uL59SmUS+mnDVb2g5gQrp4Xl08J+jmeXXxnFrTtaQrSVPNpCtJDepa0u1q36mL59XFc4JunlcXz6k1nbqQJknTrmuVriRNNZOuJDWoE0k3yeYklybZleTUtuMZhyRnJdmd5PttxzJOSQ5N8qUklyTZmeSVbce0Xkl+J8m3knynf05vbjumcUqyIcm3k3yu7Vi6YOaTbpINwGnAccCRwPOSHNluVGPxIWBz20FMwDzw6qp6CPAo4GUd+N/rFuBJVfUw4Chgc5JHtRvSWL0SuKTtILpi5pMucAywq6ouq6rfAFuB41uOad2q6svAtW3HMW5VdXVV/Xf/51/R+8u8sd2o1qd6buyvHtBfOnGFOskm4BnAmW3H0hVdSLobgSsG1ueY8b/E+4skhwF/Anyz5VDWrf9P8IuA3cAXq2rmz6nvvcBfA9P9vMQZ0oWkm2U+60SV0WVJDgY+Dbyqqm5oO571qqqFqjoK2AQck+ShLYe0bkmeCeyuqgvbjqVLupB054BDB9Y3AVe1FItWIMkB9BLuR6vq7LbjGaeq+iVwLt3oxz8aeHaSy+m17Z6U5CPthjT7upB0dwBHJDk8yYHACcC2lmPSPiQJ8AHgkqp6d9vxjEOSeyY5pP/zHYGnAD9oNagxqKrXVtWmqjqM3t+r/6qqv2g5rJk380m3quaBU4Bz6F2U+URV7Ww3qvVL8nHgG8CDkswlObntmMbk0cAL6FVNF/WXp7cd1DrdB/hSku/SKwK+WFVOr9KyvA1Ykho085WuJM0Sk64kNcikK0kNMulKUoNMupLUIJOuJDXIpCtJDfo/KuSnwhX87q0AAAAASUVORK5CYII="
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="degrees" class="doc_header"><code>degrees</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L187" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>degrees</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>sigma</code></strong>:<code>~SigmaType</code>=<em><code>'std'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Validated via points.csv file

- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/degrees.m

- compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927

- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"std"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian
    kernel.

fac (int): Rescale kernel bandwidth. Defaults to `1`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>d_hat (np.ndarray): N x 1 vector of the degree at each point in data of size N

s_hat (np.ndarray): N x 1 vector of the sparsity at each point,
    `s_hat=np.divide(1, d_hat)`

sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">degrees</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Validated via points.csv file</span>

<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/degrees.m</span>

<span class="sd">        - compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>
<span class="sd">        </span>
<span class="sd">        - `a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;std&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        fac (int): Rescale kernel bandwidth. Defaults to `1`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        d_hat (np.ndarray): N x 1 vector of the degree at each point in data of size N</span>

<span class="sd">        s_hat (np.ndarray): N x 1 vector of the sparsity at each point, </span>
<span class="sd">            `s_hat=np.divide(1, d_hat)`</span>
<span class="sd">        </span>
<span class="sd">        sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">validate_sigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="n">fac</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
    <span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">d_hat</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">s_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">sigma</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">degrees</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([0.0232194 , 0.01366118, 0.00296261, 0.02374361, 0.01619097,
        0.01638025, 0.01337635, 0.02022532, 0.02639145, 0.02372243,
        0.03391127, 0.01315071, 0.03394528, 0.03058909, 0.0218781 ,
        0.02267789, 0.02238982, 0.00341027, 0.00252961, 0.01624739,
        0.02322763, 0.0233943 , 0.00326422, 0.01259218, 0.00851955,
        0.01849438, 0.02108075, 0.01924706, 0.02372026, 0.01779681,
        0.01632197, 0.02953699, 0.01374419, 0.03345346, 0.01321157,
        0.02851005, 0.01984902, 0.03084948, 0.03391855, 0.02068446,
        0.01644617, 0.03352726, 0.02494909, 0.00331068, 0.02134958,
        0.03384447, 0.00760993, 0.00861353, 0.02383809, 0.02036809,
        0.02660306, 0.0255901 , 0.01668932, 0.0134559 , 0.01837106,
        0.01332942, 0.02059994, 0.02531346, 0.02325324, 0.0208165 ,
        0.02344518, 0.02555666, 0.0329378 , 0.02315835, 0.01297086,
        0.00999624, 0.00886615, 0.01941506, 0.01366177, 0.00844297,
        0.03205047, 0.02435234, 0.027467  , 0.02559419, 0.03190258,
        0.03394753, 0.0126226 , 0.0164056 , 0.01624739, 0.00870302,
        0.02439684, 0.01613691, 0.01606652, 0.02530954, 0.0271946 ,
        0.02002133, 0.01315266, 0.01349499, 0.0255792 , 0.02463929,
        0.01107903, 0.03391973, 0.02275449, 0.02317268, 0.01601047,
        0.01818579, 0.01582495, 0.01954898, 0.01777067, 0.01809878]),
 array([ 43.06742812,  73.20009916, 337.54064013,  42.11659248,
         61.76281079,  61.04912168,  74.75880093,  49.44297936,
         37.8910603 ,  42.15419403,  29.48871758,  76.0415287 ,
         29.45917525,  32.69139385,  45.70780811,  44.09581085,
         44.66316448, 293.2323214 , 395.31765012,  61.54835381,
         43.05218205,  42.74545187, 306.35168061,  79.41435493,
        117.37715848,  54.07047774,  47.43665221,  51.95599115,
         42.15805572,  56.18985898,  61.26711708,  33.85585049,
         72.75802893,  29.89227379,  75.69125557,  35.07535623,
         50.38031482,  32.41545699,  29.48239072,  48.3454789 ,
         60.80444106,  29.82647529,  40.08162432, 302.05231866,
         46.83931798,  29.54692098, 131.40718042, 116.09636573,
         41.9496639 ,  49.09641243,  37.5896546 ,  39.07760785,
         59.91855172,  74.31686651,  54.43343637,  75.02203532,
         48.54383967,  39.50466758,  43.00476403,  48.03882484,
         42.65268991,  39.12874584,  30.36025628,  43.18096091,
         77.09586807, 100.03762779, 112.78854894,  51.50640008,
         73.19697609, 118.4417783 ,  31.2007888 ,  41.06382287,
         36.40732059,  39.07136804,  31.34542267,  29.45722074,
         79.22298209,  60.95480273,  61.54835381, 114.90259097,
         40.98891427,  61.96973148,  62.24121332,  39.51079134,
         36.77200938,  49.94672629,  76.03023935,  74.10156119,
         39.09427067,  40.58558138,  90.26064949,  29.48136649,
         43.947363  ,  43.15425941,  62.45911837,  54.98799187,
         63.19137139,  51.1535671 ,  56.2724951 ,  55.25234019]),
 0.21378502556158857)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">degrees</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([1., 1., 1., 1., 1.]), array([1., 1., 1., 1., 1.]), 4.183300132670378)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="local_covariance" class="doc_header"><code>local_covariance</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L255" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>local_covariance</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>n_jobs</code></strong>=<em><code>-1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Validated with points.csv

- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/local_covariance.m

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"std"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

n_jobs (int): Number of cores to use. Defaults to `-1` (all but one core).

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>local_cov (np.ndarray):  N-length cell of local covariance matrices of the Gaussian
    generated noise.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">local_covariance</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Validated with points.csv</span>
<span class="sd">        </span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/local_covariance.m</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;std&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        n_jobs (int): Number of cores to use. Defaults to `-1` (all but one core).</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        local_cov (np.ndarray):  N-length cell of local covariance matrices of the Gaussian</span>
<span class="sd">            generated noise. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">local_cov</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neigh</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
    <span class="n">neigh</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>    
        <span class="n">idx</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">:]</span>
        <span class="n">local_cov</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">local_cov</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">local_covariance</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[[ 1.41202391e-03,  4.33863408e-04],
        [ 4.33863408e-04,  1.33544229e-04]],

       [[ 1.09934026e-03, -5.96880448e-04],
        [-5.96880448e-04,  3.24330087e-04]],

       [[ 1.52697277e-02, -1.15356081e-02],
        [-1.15356081e-02,  8.75111087e-03]],

       [[ 1.41202391e-03,  4.33863408e-04],
        [ 4.33863408e-04,  1.33544229e-04]],

       [[ 9.64207080e-04, -4.62324260e-04],
        [-4.62324260e-04,  2.21791583e-04]],

       [[ 9.05869617e-05,  8.25870282e-04],
        [ 8.25870282e-04,  9.00293104e-03]],

       [[ 1.09934026e-03, -5.96880448e-04],
        [-5.96880448e-04,  3.24330087e-04]],

       [[ 6.40960031e-03,  5.00768749e-03],
        [ 5.00768749e-03,  3.93175190e-03]],

       [[ 1.98336858e-04,  4.65469608e-04],
        [ 4.65469608e-04,  1.09492791e-03]],

       [[ 1.62730628e-03,  1.49884579e-03],
        [ 1.49884579e-03,  1.38273114e-03]],

       [[ 3.50843082e-05,  4.83765081e-05],
        [ 4.83765081e-05,  6.67073842e-05]],

       [[ 1.09934026e-03, -5.96880448e-04],
        [-5.96880448e-04,  3.24330087e-04]],

       [[ 3.50843082e-05,  4.83765081e-05],
        [ 4.83765081e-05,  6.67073842e-05]],

       [[ 9.92806518e-04,  1.83279074e-03],
        [ 1.83279074e-03,  3.40108037e-03]],

       [[ 2.31502746e-04,  7.94536724e-04],
        [ 7.94536724e-04,  2.74258993e-03]],

       [[ 2.76720526e-04, -5.29237568e-04],
        [-5.29237568e-04,  1.01306678e-03]],

       [[ 3.03565112e-04,  9.46518940e-04],
        [ 9.46518940e-04,  2.96987778e-03]],

       [[ 4.97605891e-02,  2.84016196e-02],
        [ 2.84016196e-02,  1.66876465e-02]],

       [[ 4.97605891e-02,  2.84016196e-02],
        [ 2.84016196e-02,  1.66876465e-02]],

       [[ 4.03301956e-04, -1.85735755e-04],
        [-1.85735755e-04,  8.55632473e-05]],

       [[ 3.36402167e-04, -1.09480277e-03],
        [-1.09480277e-03,  3.58842853e-03]],

       [[ 1.41202391e-03,  4.33863408e-04],
        [ 4.33863408e-04,  1.33544229e-04]],

       [[ 3.59725151e-02, -3.72227486e-02],
        [-3.72227486e-02,  3.53092905e-01]],

       [[ 4.32662020e-03, -3.87509114e-03],
        [-3.87509114e-03,  3.48351657e-03]],

       [[ 1.63953073e-02,  2.18872476e-03],
        [ 2.18872476e-03,  3.30278958e-04]],

       [[ 7.30449360e-05, -5.38378818e-04],
        [-5.38378818e-04,  4.28307825e-03]],

       [[ 3.07500364e-04, -1.40658430e-03],
        [-1.40658430e-03,  6.51094741e-03]],

       [[ 2.37217246e-04,  1.10053143e-03],
        [ 1.10053143e-03,  5.20868884e-03]],

       [[ 2.22523775e-03,  5.23319333e-04],
        [ 5.23319333e-04,  1.23898076e-04]],

       [[ 7.30449360e-05, -5.38378818e-04],
        [-5.38378818e-04,  4.28307825e-03]],

       [[ 4.03301956e-04, -1.85735755e-04],
        [-1.85735755e-04,  8.55632473e-05]],

       [[ 6.55725114e-04,  7.06975794e-04],
        [ 7.06975794e-04,  7.62447137e-04]],

       [[ 8.11777960e-03, -5.90201259e-03],
        [-5.90201259e-03,  4.32931358e-03]],

       [[ 8.14263869e-05,  1.18738039e-04],
        [ 1.18738039e-04,  1.73155122e-04]],

       [[ 8.84909335e-03, -3.28112949e-03],
        [-3.28112949e-03,  1.22448120e-03]],

       [[ 4.67134908e-04,  9.59743823e-04],
        [ 9.59743823e-04,  1.97347666e-03]],

       [[ 2.37217246e-04,  1.10053143e-03],
        [ 1.10053143e-03,  5.20868884e-03]],

       [[ 9.92806518e-04,  1.83279074e-03],
        [ 1.83279074e-03,  3.40108037e-03]],

       [[ 6.68672425e-05,  9.13880811e-05],
        [ 9.13880811e-05,  1.24906784e-04]],

       [[ 1.29767181e-03,  6.92799800e-04],
        [ 6.92799800e-04,  3.70316689e-04]],

       [[ 1.73650421e-05, -2.66863213e-04],
        [-2.66863213e-04,  4.44307729e-03]],

       [[ 3.19151075e-04,  3.99588342e-04],
        [ 3.99588342e-04,  5.00494446e-04]],

       [[ 2.53524807e-04, -5.42494869e-04],
        [-5.42494869e-04,  1.16342251e-03]],

       [[ 5.84865303e-02, -7.67101978e-02],
        [-7.67101978e-02,  1.05685791e-01]],

       [[ 2.76720526e-04, -5.29237568e-04],
        [-5.29237568e-04,  1.01306678e-03]],

       [[ 1.33013436e-04,  1.77845133e-04],
        [ 1.77845133e-04,  2.37837616e-04]],

       [[ 2.32612801e-02,  8.89381755e-03],
        [ 8.89381755e-03,  3.52274123e-03]],

       [[ 1.63953073e-02,  2.18872476e-03],
        [ 2.18872476e-03,  3.30278958e-04]],

       [[ 2.77701779e-03,  7.39187184e-04],
        [ 7.39187184e-04,  1.98001582e-04]],

       [[ 1.28579322e-03,  1.82374774e-05],
        [ 1.82374774e-05,  3.82102453e-07]],

       [[ 1.98336858e-04,  4.65469608e-04],
        [ 4.65469608e-04,  1.09492791e-03]],

       [[ 9.11035181e-05, -2.22309900e-04],
        [-2.22309900e-04,  5.43176951e-04]],

       [[ 1.46628836e-04,  1.04440085e-03],
        [ 1.04440085e-03,  7.84955335e-03]],

       [[ 8.84909335e-03, -3.28112949e-03],
        [-3.28112949e-03,  1.22448120e-03]],

       [[ 2.23639886e-03, -3.21930296e-05],
        [-3.21930296e-05,  1.33842348e-06]],

       [[ 1.09934026e-03, -5.96880448e-04],
        [-5.96880448e-04,  3.24330087e-04]],

       [[ 1.28579322e-03,  1.82374774e-05],
        [ 1.82374774e-05,  3.82102453e-07]],

       [[ 1.55258039e-04, -3.52468952e-04],
        [-3.52468952e-04,  8.00521767e-04]],

       [[ 2.76720526e-04, -5.29237568e-04],
        [-5.29237568e-04,  1.01306678e-03]],

       [[ 2.54299681e-03,  1.10553465e-03],
        [ 1.10553465e-03,  4.81972088e-04]],

       [[ 1.70320008e-03,  3.41522880e-04],
        [ 3.41522880e-04,  6.89434065e-05]],

       [[ 9.11035181e-05, -2.22309900e-04],
        [-2.22309900e-04,  5.43176951e-04]],

       [[ 3.05115086e-04,  3.76275314e-04],
        [ 3.76275314e-04,  4.64175195e-04]],

       [[ 1.41202391e-03,  4.33863408e-04],
        [ 4.33863408e-04,  1.33544229e-04]],

       [[ 1.59523817e-02, -2.72738125e-03],
        [-2.72738125e-03,  4.79832901e-04]],

       [[ 2.21145698e-02, -4.81757696e-03],
        [-4.81757696e-03,  1.11120679e-03]],

       [[ 2.53004439e-02, -2.08627141e-03],
        [-2.08627141e-03,  3.12845445e-04]],

       [[ 1.29767181e-03,  6.92799800e-04],
        [ 6.92799800e-04,  3.70316689e-04]],

       [[ 2.16859575e-03, -8.06497593e-04],
        [-8.06497593e-04,  3.00064655e-04]],

       [[ 2.62524700e-02,  9.09276955e-04],
        [ 9.09276955e-04,  1.03614073e-04]],

       [[ 4.52476745e-04,  5.25226117e-04],
        [ 5.25226117e-04,  6.10224259e-04]],

       [[ 2.16973099e-04, -6.32178424e-04],
        [-6.32178424e-04,  1.84553961e-03]],

       [[ 1.01897703e-03,  1.04236390e-03],
        [ 1.04236390e-03,  1.06828143e-03]],

       [[ 9.11035181e-05, -2.22309900e-04],
        [-2.22309900e-04,  5.43176951e-04]],

       [[ 4.52476745e-04,  5.25226117e-04],
        [ 5.25226117e-04,  6.10224259e-04]],

       [[ 3.50843082e-05,  4.83765081e-05],
        [ 4.83765081e-05,  6.67073842e-05]],

       [[ 4.32662020e-03, -3.87509114e-03],
        [-3.87509114e-03,  3.48351657e-03]],

       [[ 9.64207080e-04, -4.62324260e-04],
        [-4.62324260e-04,  2.21791583e-04]],

       [[ 4.03301956e-04, -1.85735755e-04],
        [-1.85735755e-04,  8.55632473e-05]],

       [[ 1.63953073e-02,  2.18872476e-03],
        [ 2.18872476e-03,  3.30278958e-04]],

       [[ 2.18262797e-04,  5.89692854e-04],
        [ 5.89692854e-04,  1.59630839e-03]],

       [[ 4.03301956e-04, -1.85735755e-04],
        [-1.85735755e-04,  8.55632473e-05]],

       [[ 9.33625465e-06,  5.29494035e-05],
        [ 5.29494035e-05,  8.51486673e-03]],

       [[ 1.14479098e-04, -3.15635390e-04],
        [-3.15635390e-04,  8.71027186e-04]],

       [[ 1.01897703e-03,  1.04236390e-03],
        [ 1.04236390e-03,  1.06828143e-03]],

       [[ 1.29767181e-03,  6.92799800e-04],
        [ 6.92799800e-04,  3.70316689e-04]],

       [[ 5.74112766e-03, -5.80746149e-03],
        [-5.80746149e-03,  5.92966835e-03]],

       [[ 8.11777960e-03, -5.90201259e-03],
        [-5.90201259e-03,  4.32931358e-03]],

       [[ 1.98336858e-04,  4.65469608e-04],
        [ 4.65469608e-04,  1.09492791e-03]],

       [[ 2.17616103e-04, -4.36111375e-04],
        [-4.36111375e-04,  8.74497235e-04]],

       [[ 1.09934026e-03, -5.96880448e-04],
        [-5.96880448e-04,  3.24330087e-04]],

       [[ 3.50843082e-05,  4.83765081e-05],
        [ 4.83765081e-05,  6.67073842e-05]],

       [[ 3.95951887e-03,  5.33523986e-04],
        [ 5.33523986e-04,  7.45516454e-05]],

       [[ 1.70320008e-03,  3.41522880e-04],
        [ 3.41522880e-04,  6.89434065e-05]],

       [[ 2.23639886e-03, -3.21930296e-05],
        [-3.21930296e-05,  1.33842348e-06]],

       [[ 1.29767181e-03,  6.92799800e-04],
        [ 6.92799800e-04,  3.70316689e-04]],

       [[ 3.40935350e-03, -4.91709368e-03],
        [-4.91709368e-03,  7.11756913e-03]],

       [[ 1.28579322e-03,  1.82374774e-05],
        [ 1.82374774e-05,  3.82102453e-07]],

       [[ 2.23639886e-03, -3.21930296e-05],
        [-3.21930296e-05,  1.33842348e-06]],

       [[ 7.30449360e-05, -5.38378818e-04],
        [-5.38378818e-04,  4.28307825e-03]]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data1</span><span class="p">,</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]]),
 array([[[62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5]],
 
        [[62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5]],
 
        [[62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5]],
 
        [[62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5]],
 
        [[62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5],
         [62.5, 62.5, 62.5, 62.5, 62.5]]]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data2</span><span class="p">,</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/home/solstice/anaconda3/envs/ml/lib/python3.9/site-packages/threadpoolctl.py:762: RuntimeWarning: 
Found Intel OpenMP (&#39;libiomp&#39;) and LLVM OpenMP (&#39;libomp&#39;) loaded at
the same time. Both libraries are known to be incompatible and this
can cause random crashes or deadlocks on Linux when loaded in the
same Python program.
Using threadpoolctl may cause crashes or deadlocks. For more
information and possible workarounds, please see
    https://github.com/joblib/threadpoolctl/blob/master/multiple_openmp.md

  warnings.warn(msg, RuntimeWarning)
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[0., 1., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]]),
 array([[[0. , 0. , 0. , 0. , 0. ],
         [0. , 0.2, 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ]],
 
        [[0. , 0. , 0. , 0. , 0. ],
         [0. , 0.2, 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ]],
 
        [[0. , 0. , 0. , 0. , 0. ],
         [0. , 0.2, 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ]],
 
        [[0. , 0. , 0. , 0. , 0. ],
         [0. , 0.2, 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ]],
 
        [[0. , 0. , 0. , 0. , 0. ],
         [0. , 0.2, 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ],
         [0. , 0. , 0. , 0. , 0. ]]]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="feature_scale" class="doc_header"><code>feature_scale</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L299" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>feature_scale</code>(<strong><code>x</code></strong>:<code>ndarray</code>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">feature_scale</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fp</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="numpts" class="doc_header"><code>numpts</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L305" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>numpts</code>(<strong><code>degree</code></strong>:<code>ndarray</code>, <strong><code>noise_cov</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>ndarray</code>]=<em><code>1</code></em>, <strong><code>kernel_sigma</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>ndarray</code>]=<em><code>1</code></em>, <strong><code>dim</code></strong>:<code>Union</code>[<code>int</code>, <code>typing.Literal[None]</code>]=<em><code>None</code></em>, <strong><code>M</code></strong>:<code>int</code>=<em><code>0</code></em>, <strong><code>equalize</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>suppress</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Validated with points.csv

- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/numpts.m

- compute the number of new points to generate around each point in a
    dataset https://arxiv.org/abs/1802.04927

- `M` (number of points to generate)
    + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`
        will negatively impact density equalization, `M &lt;&lt; N` is not recommended
        and `M &lt;&lt;&lt; N` may fail.

    + `not M and equalize`: then density equalization will not be scaled.

    + `M and not equalize`: then approximately `M` points will be generated
        according to a constant difference of max density.

    + `not M and not equalize`: then `M` is approximately N points.

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>degree (np.ndarray): Degree estimate of the N x D data in shape N x 1.


noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation.
    Accepts a scalar for a unifrom Gaussian noise variance or an array
    containing D x D local covariance matricies for Gaussian generated noise.
    Defaults to `1`.

kernel_sigma (int|float|np.ndarray): Degree estimate bandwith. A scalar for uniform
    bandwidth or an N x 1 array for adaptive bandwidth. Defaults to `1`.

dim (int): Generated noise dimension. Defaults to `D` if availible from
    `noise_cov` else required.

M (int): Number of points to generate. Can affect strength of density equalization.
    Can accept positive scalars. Defaults to `0`.

equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults
    to `False`.

suppress (bool): Enabled / disable point generation errors. Defaults to `False`.
    Deprecated.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>npts (np.ndarray): The number of points to generate at each point</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">numpts</span><span class="p">(</span>
    <span class="n">degree</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">noise_cov</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">kernel_sigma</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">dim</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">suppress</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Validated with points.csv</span>
<span class="sd">        </span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/numpts.m</span>

<span class="sd">        - compute the number of new points to generate around each point in a </span>
<span class="sd">            dataset https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `M` (number of points to generate)</span>
<span class="sd">            + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`</span>
<span class="sd">                will negatively impact density equalization, `M &lt;&lt; N` is not recommended</span>
<span class="sd">                and `M &lt;&lt;&lt; N` may fail.</span>

<span class="sd">            + `not M and equalize`: then density equalization will not be scaled.</span>
<span class="sd">            </span>
<span class="sd">            + `M and not equalize`: then approximately `M` points will be generated</span>
<span class="sd">                according to a constant difference of max density.</span>
<span class="sd">            </span>
<span class="sd">            + `not M and not equalize`: then `M` is approximately N points.</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        degree (np.ndarray): Degree estimate of the N x D data in shape N x 1.</span>


<span class="sd">        noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation. </span>
<span class="sd">            Accepts a scalar for a unifrom Gaussian noise variance or an array </span>
<span class="sd">            containing D x D local covariance matricies for Gaussian generated noise.</span>
<span class="sd">            Defaults to `1`.</span>
<span class="sd">        </span>
<span class="sd">        kernel_sigma (int|float|np.ndarray): Degree estimate bandwith. A scalar for uniform</span>
<span class="sd">            bandwidth or an N x 1 array for adaptive bandwidth. Defaults to `1`.</span>
<span class="sd">        </span>
<span class="sd">        dim (int): Generated noise dimension. Defaults to `D` if availible from </span>
<span class="sd">            `noise_cov` else required. </span>

<span class="sd">        M (int): Number of points to generate. Can affect strength of density equalization.</span>
<span class="sd">            Can accept positive scalars. Defaults to `0`.</span>

<span class="sd">        equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults</span>
<span class="sd">            to `False`.</span>

<span class="sd">        suppress (bool): Enabled / disable point generation errors. Defaults to `False`.</span>
<span class="sd">            Deprecated.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        npts (np.ndarray): The number of points to generate at each point</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">number_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># NOTE: validated with points.csv</span>
    <span class="k">if</span> <span class="n">equalize</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Density equalizaton according to scalar noise covariance...&#39;</span><span class="p">)</span>
            <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="o">-</span> <span class="n">degree</span><span class="p">)</span> <span class="o">*</span> \
                <span class="p">(</span> <span class="p">(</span><span class="n">kernel_sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">noise_cov</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">noise_cov</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Density equalizaton according to local noise covariance...&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel_sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">kernel_sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">kernel_sigma</span>

                <span class="n">number_estimate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="o">-</span> <span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span> 
                        <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> 
                    <span class="p">),</span> <span class="mf">0.5</span><span class="p">)</span>
            
        <span class="c1"># NOTE: validated with points.csv        </span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Applying total generation constraint M.&#39;</span><span class="p">)</span>
            <span class="n">number_save</span> <span class="o">=</span> <span class="n">number_estimate</span>
            <span class="n">number_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">M</span> <span class="o">/</span> <span class="n">number_sum</span> <span class="o">&lt;</span> <span class="mf">1e-1</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">M</span> <span class="o">/</span> <span class="n">number_sum</span> <span class="o">*</span> <span class="mi">100</span><span class="si">}</span><span class="s1">% of equalized total. &#39;</span>
                    <span class="s1">&#39;Output will reflecct equalization. Increased M suggested.&#39;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">number_estimate</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-17</span><span class="p">)</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
    
    <span class="c1"># NOTE: validated with points.csv            </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating without density equalization&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No M supplied, M = N&#39;</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">N</span>

        <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="o">-</span> <span class="n">degree</span><span class="p">)</span>
        <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">number_estimate</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-17</span><span class="p">)</span>

        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Point generation estimate &lt; 0, either provide/increase M or decrease noise_cov.&#39;</span><span class="p">)</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Point generation estimate &gt; 1e4, either provide/decrease M or increase noise_cov.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">npts</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">degree_sigma</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">noise</span> <span class="o">=</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">noise_cov</span> <span class="o">=</span> <span class="n">noise</span>
    
<span class="n">npts</span> <span class="o">=</span> <span class="n">numpts</span><span class="p">(</span>
    <span class="n">d_hat</span><span class="p">,</span> <span class="n">noise_cov</span><span class="o">=</span><span class="n">noise_cov</span><span class="p">,</span> <span class="n">kernel_sigma</span><span class="o">=</span><span class="n">degree_sigma</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">pnts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">npts</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([0., 1., 2., 0., 1., 1., 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0.,
       2., 2., 1., 0., 0., 2., 1., 1., 1., 0., 1., 0., 1., 1., 0., 1., 0.,
       1., 0., 1., 0., 0., 0., 1., 0., 0., 2., 0., 0., 1., 1., 0., 0., 0.,
       0., 1., 1., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1., 1.,
       1., 1., 0., 0., 0., 0., 0., 0., 1., 1., 1., 1., 0., 1., 1., 0., 0.,
       0., 1., 1., 0., 0., 1., 0., 0., 0., 1., 1., 1., 1., 1., 1.])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate" class="doc_header"><code>generate</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L432" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>npts</code></strong>:<code>ndarray</code>, <strong><code>noise_cov</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>ndarray</code>], <strong><code>labels</code></strong>:<code>list</code>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Validated with points.csv

- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/generate.m

- compute the number of new points to generate around each point in a
    dataset https://arxiv.org/abs/1802.04927

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


npts (np.ndarray): Number of points to generate around each point in data,
    with shape N x 1.

noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation.
    Accepts a scalar for a unifrom Gaussian noise variance or an array
    containing D x D local covariance matricies for Gaussian generated noise.

labels (list): Labels to add to new points

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>random_points (np.ndarray): Noisy generated points with shape `np.sum(npts) x D`.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">generate</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">npts</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">noise_cov</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
    <span class="n">labels</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Validated with points.csv</span>

<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/generate.m</span>

<span class="sd">        - compute the number of new points to generate around each point in a </span>
<span class="sd">            dataset https://arxiv.org/abs/1802.04927</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        npts (np.ndarray): Number of points to generate around each point in data,</span>
<span class="sd">            with shape N x 1.</span>
<span class="sd">           </span>
<span class="sd">        noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation. </span>
<span class="sd">            Accepts a scalar for a unifrom Gaussian noise variance or an array </span>
<span class="sd">            containing D x D local covariance matricies for Gaussian generated noise.</span>
<span class="sd">                    </span>
<span class="sd">        labels (list): Labels to add to new points</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        random_points (np.ndarray): Noisy generated points with shape `np.sum(npts) x D`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    

    <span class="n">rep_centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rep_cov</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">labels_out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">npts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span> <span class="c1"># constant cov, no need to replicate cov.</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Constant covariance, no need to replicate covariance&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="c1"># replicate data[i] to make npts[i] centers for mvnrnd</span>
            <span class="n">new_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">rep_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_center</span><span class="p">)</span><span class="c1"># = [rep_centers, new_center]</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">new_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">labels_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_out</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">]</span>
        <span class="c1"># generate</span>
        <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
            <span class="n">rep_centers</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">noise_cov</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>

            <span class="c1"># replicate centers npts[i] times</span>
            <span class="n">new_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">new_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">labels_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_out</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">]</span>
            
            
            <span class="c1"># rep_centers = [rep_centers, new_center]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">new_center</span><span class="p">):</span>
                <span class="n">rep_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_center</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># replicate the covariance matrix   </span>
                <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">rep_cov</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> 
            

        <span class="k">if</span> <span class="n">rep_cov</span><span class="p">:</span>
            <span class="n">rep_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">rep_cov</span><span class="p">)</span>
            <span class="n">rep_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">rep_centers</span><span class="p">)</span>


        <span class="n">random_points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rep_centers</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">random_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">rep_cov</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="p">)</span>
        
        <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">random_points</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">random_points</span><span class="p">,</span> <span class="n">labels_out</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">rnpts</span><span class="p">,</span> <span class="n">labels_out</span> <span class="o">=</span> <span class="n">generate</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">noise_cov</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">[])</span> 
<span class="n">rnpts</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/tmp/ipykernel_10384/2846601451.py:1: RuntimeWarning: covariance is not positive-semidefinite.
  rnpts, labels_out = generate(pnts, npts, noise_cov, labels = [])
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[-0.4089356 , -0.9144342 ],
       [-0.87979382, -0.56857072],
       [-0.8403116 , -0.59806596],
       [ 0.4277006 ,  0.90309348],
       [ 1.00035528,  0.00703791]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="matlab_percentile" class="doc_header"><code>matlab_percentile</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L529" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>matlab_percentile</code>(<strong><code>in_data</code></strong>, <strong><code>percentiles</code></strong>)</p>
</blockquote>
<p>Calculate percentiles in the way IDL and Matlab do it.</p>
<p>By using interpolation between the lowest an highest rank and the
minimum and maximum outside.</p>
<p>Notes:</p>

<pre><code>- shamelessly yoinked from https://github.com/numpy/numpy/issues/6620

</code></pre>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>in_data: numpy.ndarray
    input data
percentiles: numpy.ndarray
    percentiles at which to calculate the values</p>
<h2 id="Returns">Returns<a class="anchor-link" href="#Returns"> </a></h2><p>perc: numpy.ndarray
    values of the percentiles</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matlab_percentile</span><span class="p">(</span><span class="n">in_data</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate percentiles in the way IDL and Matlab do it.</span>

<span class="sd">    By using interpolation between the lowest an highest rank and the</span>
<span class="sd">    minimum and maximum outside.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - shamelessly yoinked from https://github.com/numpy/numpy/issues/6620</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_data: numpy.ndarray</span>
<span class="sd">        input data</span>
<span class="sd">    percentiles: numpy.ndarray</span>
<span class="sd">        percentiles at which to calculate the values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    perc: numpy.ndarray</span>
<span class="sd">        values of the percentiles</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">in_data</span><span class="p">)</span>
    <span class="n">p_rank</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
    <span class="n">perc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">percentiles</span><span class="p">,</span> <span class="n">p_rank</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">perc</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="magic" class="doc_header"><code>magic</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L559" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>magic</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>kernel</code></strong>:<code>ndarray</code>, <strong><code>t</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>rescale</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/magic.m

- MAGIC (Markov Affinity based Gaussian Imputation of Cells) see:
    + https://www.biorxiv.org/content/early/2017/02/25/111591
    + https://arxiv.org/abs/1802.04927

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


kernel (np.ndarray): N x N kernel or affinity matrix.

t (int): Time steps to apply MAGIC for. Controls low pass filter cutoff.
    Defaults to `1`.

rescale (bool): Rescale 95th percentile of imputed data to match original
    data. Defaults to `True`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>data_imputed (np.ndarray): M x D Data points imputed via MAGIC using kernel.

diffusion_operator (np.ndarray): M x M Markov matrix built from kernel.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">magic</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">kernel</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">t</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rescale</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/magic.m</span>

<span class="sd">        - MAGIC (Markov Affinity based Gaussian Imputation of Cells) see:</span>
<span class="sd">            + https://www.biorxiv.org/content/early/2017/02/25/111591</span>
<span class="sd">            + https://arxiv.org/abs/1802.04927</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        kernel (np.ndarray): N x N kernel or affinity matrix.</span>
<span class="sd">           </span>
<span class="sd">        t (int): Time steps to apply MAGIC for. Controls low pass filter cutoff.</span>
<span class="sd">            Defaults to `1`.</span>
<span class="sd">                    </span>
<span class="sd">        rescale (bool): Rescale 95th percentile of imputed data to match original</span>
<span class="sd">            data. Defaults to `True`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        data_imputed (np.ndarray): M x D Data points imputed via MAGIC using kernel.</span>

<span class="sd">        diffusion_operator (np.ndarray): M x M Markov matrix built from kernel.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Data does not match kernel size&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="c1"># build diffusion operator</span>
    <span class="n">diffusion_degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span> 
    <span class="n">diffusion_degree</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">diffusion_degree</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">diffusion_operator</span> <span class="o">=</span> <span class="n">diffusion_degree</span> <span class="o">@</span> <span class="n">kernel</span>

    <span class="n">data_imputed</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="c1"># data_imputed = diffusion_operator * data_imputed</span>
        <span class="n">data_imputed</span> <span class="o">=</span> <span class="n">diffusion_operator</span> <span class="o">@</span> <span class="n">data_imputed</span>


    <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
        <span class="c1"># NOTE: Heuristic by David to fix vanishing norm when multiplying by diffusion operator</span>
        <span class="n">data_imputed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
            <span class="n">data_imputed</span><span class="p">,</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">matlab_percentile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">95</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">matlab_percentile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_imputed</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">data_imputed</span><span class="p">,</span> <span class="n">diffusion_operator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="mgc_magic" class="doc_header"><code>mgc_magic</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L629" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>mgc_magic</code>(<strong><code>X</code></strong>:<code>ndarray</code>, <strong><code>Y</code></strong>:<code>ndarray</code>, <strong><code>s_hat</code></strong>:<code>ndarray</code>, <strong><code>sigma</code></strong>:<code>~SigmaType</code>=<em><code>'knn'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>t</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>magic_rescale</code></strong>:<code>bool</code>=<em><code>1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/mgc_magic.m

- MGC_MAGIC (Measure-based Gaussian Correlation Kernel w/ MAGIC):
    + https://arxiv.org/abs/1802.04927

- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

- `t`
    + `t=0`: [`mgc_magic`](/sk_sugar/core.html#mgc_magic) is not called
    + `t&gt;0`: applies [`mgc_magic`](/sk_sugar/core.html#mgc_magic) steps of diffusion.

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>X (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

Y (np.ndarray): M x D Data matrix. N rows are measurements, D columns are features.

s_hat (np.ndarray): M x 1 measure vector. M entries correspond to measures on the rows of Y.

sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"std"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian
    kernel.

fac (int): Rescale kernel bandwidth. Defaults to `1`.

t (int): Apply MGC MAGIC to diffuse new points. If less than `0` [`mgc_magic`](/sk_sugar/core.html#mgc_magic)
    is not called. Defaults to `1`.

magic_rescale (bool): Rescale 95th percentile of imputed data to match original
    data. Defaults to `True`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>new_data (np.ndarray): M x D New points corrected using MGC MAGIC through X.

mgc_kernel (np.ndarray): M x M MGC kernel built over Y through X via `s_hat`.

mgc_diffusion_operator (np.ndarray): M x M row stochastic MGC
    markov matrix / diffusion operator</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mgc_magic</span><span class="p">(</span>
    <span class="n">X</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">Y</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">s_hat</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span> <span class="o">=</span> <span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">fac</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/mgc_magic.m</span>

<span class="sd">        - MGC_MAGIC (Measure-based Gaussian Correlation Kernel w/ MAGIC): </span>
<span class="sd">            + https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">        - `a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">        - `t`</span>
<span class="sd">            + `t=0`: `mgc_magic` is not called</span>
<span class="sd">            + `t&gt;0`: applies `mgc_magic` steps of diffusion. </span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        X (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>
<span class="sd">        </span>
<span class="sd">        Y (np.ndarray): M x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        s_hat (np.ndarray): M x 1 measure vector. M entries correspond to measures on the rows of Y.</span>

<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;std&quot;`.</span>

<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        fac (int): Rescale kernel bandwidth. Defaults to `1`.</span>

<span class="sd">        t (int): Apply MGC MAGIC to diffuse new points. If less than `0` `mgc_magic`</span>
<span class="sd">            is not called. Defaults to `1`.</span>
<span class="sd">                    </span>
<span class="sd">        magic_rescale (bool): Rescale 95th percentile of imputed data to match original</span>
<span class="sd">            data. Defaults to `True`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        new_data (np.ndarray): M x D New points corrected using MGC MAGIC through X.</span>

<span class="sd">        mgc_kernel (np.ndarray): M x M MGC kernel built over Y through X via `s_hat`.</span>

<span class="sd">        mgc_diffusion_operator (np.ndarray): M x M row stochastic MGC </span>
<span class="sd">            markov matrix / diffusion operator</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">Y</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;mgc_magic was passed t=0, no mgc_magic was performed&#39;</span><span class="p">)</span>
    <span class="n">new_to_old</span><span class="p">,</span> <span class="n">sigma_nto</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">fac</span><span class="p">)</span>
    <span class="n">old_to_new</span><span class="p">,</span> <span class="n">sigma_otn</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">fac</span><span class="p">)</span>

    <span class="n">new_to_old_sparsity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_to_old_sparsity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">new_to_old</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">)</span>
    <span class="c1"># new_to_old_sparsity = np.matmul(new_to_old, s_hat)</span>

    <span class="c1"># NOTE: from matlab this is matrix multiply</span>
    <span class="c1"># mgc_kernel = new_to_old_sparsity * old_to_new</span>
    <span class="n">mgc_kernel</span> <span class="o">=</span> <span class="n">new_to_old_sparsity</span> <span class="o">@</span> <span class="n">old_to_new</span>
    <span class="n">mgc_kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span> <span class="p">(</span><span class="n">mgc_kernel</span> <span class="o">+</span> <span class="n">mgc_kernel</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">new_data</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="n">magic</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">magic_rescale</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">new_data</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diff</span> <span class="o">=</span> <span class="n">mgc_magic</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="n">rnd_pnts</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="s1">&#39;knn&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">new_data</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[-0.55784771, -0.81296597],
       [-0.73225017, -0.61892015],
       [-0.76553933, -0.53132798],
       [ 0.39515296,  0.93372422],
       [ 1.00019674, -0.10160751]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">new_data</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="n">magic</span><span class="p">(</span><span class="n">rnd_pnts</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="sugar" class="doc_header"><code>sugar</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L721" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>sugar</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>labels</code></strong>:<code>list</code>=<em><code>[]</code></em>, <strong><code>noise_cov</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>typing.Literal['knn']</code>]=<em><code>'knn'</code></em>, <strong><code>noise_k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>sparsity_idx</code></strong>:<code>list</code>=<em><code>[]</code></em>, <strong><code>degree_sigma</code></strong>:<code>~SigmaType</code>=<em><code>'std'</code></em>, <strong><code>degree_k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>degree_a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>degree_fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>M</code></strong>:<code>int</code>=<em><code>0</code></em>, <strong><code>equalize</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>mgc_t</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>mgc_sigma</code></strong>:<code>~SigmaType</code>=<em><code>'knn'</code></em>, <strong><code>mgc_k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>mgc_a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>mgc_fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>magic_rescale</code></strong>:<code>bool</code>=<em><code>1</code></em>, <strong><code>suppress</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>n_jobs</code></strong>:<code>int</code>=<em><code>-1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/sugar.m

- SUGAR (Geometry-based Data Generation)
    + https://arxiv.org/abs/1802.04927

- `degree_sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `degree_a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

- `M` (number of points to generate)
    + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`
        will negatively impact density equalization, `M &lt;&lt; N` is not recommended
        and `M &lt;&lt;&lt; N` may fail.

    + `not M and equalize`: then density equalization will not be scaled.

    + `M and not equalize`: then approximately `M` points will be generated
        according to a constant difference of max density.

    + `not M and not equalize`: then `M` is approximately N points.

- `mgc_t`
    + `mgc_t=0`: [`mgc_magic`](/sk_sugar/core.html#mgc_magic) is not called
    + `mgc_t&gt;0`: applies [`mgc_magic`](/sk_sugar/core.html#mgc_magic) steps of diffusion.

- `mgc_sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `mgc_a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

labels (list): N x 1 vector of classifier labels. Defaults to `[]`.

noise_cov (int|float|str): Bandwidth of Gaussian noise. Either scalar or `"knn"`.
    Defaults to `"knn"`.

noise_k (int): Neighborhood size for covariance estimation. Defaults to `5`.

sparsity_idx (list): Column indexes for sparsity estimation dimensions. If `[]`
    estimate sparsity in all dimensions. Defaults to `[]`.

degree_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to
    use or a user defined function. Valid `sigma` values include `"minmax"`, `"median"`,
    `"std"`, `"knn"`. Defaults to `"knn"`.

degree_k (int): K-nearest neighbor distance to use if `degree_sigma="knn"`. Defaults to `5`.

degree_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `degree_a=2` is the
    Gaussian kernel.

degree_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.

M (int): Number of points to generate. Can affect strength of density equalization.
    Can accept positive scalars. Defaults to `0`.

equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults
    to `False`.

mgc_t (int): Apply MGC MAGIC to diffuse new points. If less than `0` [`mgc_magic`](/sk_sugar/core.html#mgc_magic)
    is not called. Defaults to `1`.

mgc_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to
    use or a user defined function. Valid `sigma` values include `"minmax"`, `"median"`,
    `"std"`, `"knn"`. Defaults to `"knn"`.

mgc_k (int): K-nearest neighbor distance to use if `mgc_sigma="knn"`. Defaults to `5`.

mgc_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `mgc_a=2` is the Gaussian
    kernel.

mgc_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.

magic_rescale (bool): Rescale 95th percentile of imputed data to match original
    data after MAGIC. Defaults to `True`.

suppress (bool): Enabled / disable point generation errors. Defaults to `False`.
    Deprecated.

n_jobs (int): Number of cores to use. Defaults to `-1` (all but one core)/

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>Y (np.ndarray): M x D New points generated by SUGAR.

out_labels (np.ndarray): M x 1 New labels corresponding to `Y`.

d_hat (np.ndarray): N x 1 Degree estimate of data.

s_hat (np.ndarray): N x 1 Sparsity estimate of data.

sigma (np.ndarray): N x 1 or Scalar sigma used for `d_hat` computation.

noise (np.ndarray): N x D x D of local covariance matrices on `X`.

npts (np.ndarray): N x 1 number of points generated for each point in `X`.

random_points (np.ndarray): M x D random points generated around X.

mgc_kernel (np.ndarray): M x M kernel matrix of `Y` through data over `s_hat`.

mgc_diffusion_operator (np.ndarray): M x M markov matrix of `mgc_kernel`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceobj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sugar</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">labels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">noise_cov</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;knn&quot;</span><span class="p">]]</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">noise_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">sparsity_idx</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">degree_sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">degree_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">degree_a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">degree_fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mgc_t</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">mgc_sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">mgc_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">mgc_a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">mgc_fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">suppress</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="p">:</span><span class="nb">int</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/sugar.m</span>

<span class="sd">        - SUGAR (Geometry-based Data Generation)    </span>
<span class="sd">            + https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `degree_sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">        - `degree_a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">        - `M` (number of points to generate)</span>
<span class="sd">            + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`</span>
<span class="sd">                will negatively impact density equalization, `M &lt;&lt; N` is not recommended</span>
<span class="sd">                and `M &lt;&lt;&lt; N` may fail.</span>

<span class="sd">            + `not M and equalize`: then density equalization will not be scaled.</span>
<span class="sd">            </span>
<span class="sd">            + `M and not equalize`: then approximately `M` points will be generated</span>
<span class="sd">                according to a constant difference of max density.</span>
<span class="sd">            </span>
<span class="sd">            + `not M and not equalize`: then `M` is approximately N points.</span>

<span class="sd">        - `mgc_t`</span>
<span class="sd">            + `mgc_t=0`: `mgc_magic` is not called</span>
<span class="sd">            + `mgc_t&gt;0`: applies `mgc_magic` steps of diffusion. </span>

<span class="sd">        - `mgc_sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">        - `mgc_a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        labels (list): N x 1 vector of classifier labels. Defaults to `[]`.</span>
<span class="sd">        </span>
<span class="sd">        noise_cov (int|float|str): Bandwidth of Gaussian noise. Either scalar or `&quot;knn&quot;`.</span>
<span class="sd">            Defaults to `&quot;knn&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        noise_k (int): Neighborhood size for covariance estimation. Defaults to `5`.</span>

<span class="sd">        sparsity_idx (list): Column indexes for sparsity estimation dimensions. If `[]`</span>
<span class="sd">            estimate sparsity in all dimensions. Defaults to `[]`.</span>

<span class="sd">        degree_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to </span>
<span class="sd">            use or a user defined function. Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, </span>
<span class="sd">            `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to `&quot;knn&quot;`.</span>

<span class="sd">        degree_k (int): K-nearest neighbor distance to use if `degree_sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        degree_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `degree_a=2` is the </span>
<span class="sd">            Gaussian kernel.</span>
<span class="sd">        </span>
<span class="sd">        degree_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.</span>
<span class="sd">     </span>
<span class="sd">        M (int): Number of points to generate. Can affect strength of density equalization.</span>
<span class="sd">            Can accept positive scalars. Defaults to `0`.</span>

<span class="sd">        equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults</span>
<span class="sd">            to `False`.</span>

<span class="sd">        mgc_t (int): Apply MGC MAGIC to diffuse new points. If less than `0` `mgc_magic`</span>
<span class="sd">            is not called. Defaults to `1`.</span>

<span class="sd">        mgc_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to </span>
<span class="sd">            use or a user defined function. Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, </span>
<span class="sd">            `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to `&quot;knn&quot;`.</span>

<span class="sd">        mgc_k (int): K-nearest neighbor distance to use if `mgc_sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        mgc_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `mgc_a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        mgc_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.</span>
<span class="sd">                    </span>
<span class="sd">        magic_rescale (bool): Rescale 95th percentile of imputed data to match original</span>
<span class="sd">            data after MAGIC. Defaults to `True`.</span>

<span class="sd">        suppress (bool): Enabled / disable point generation errors. Defaults to `False`.</span>
<span class="sd">            Deprecated.</span>

<span class="sd">        n_jobs (int): Number of cores to use. Defaults to `-1` (all but one core)/</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        Y (np.ndarray): M x D New points generated by SUGAR.</span>

<span class="sd">        out_labels (np.ndarray): M x 1 New labels corresponding to `Y`.</span>

<span class="sd">        d_hat (np.ndarray): N x 1 Degree estimate of data.</span>

<span class="sd">        s_hat (np.ndarray): N x 1 Sparsity estimate of data.</span>

<span class="sd">        sigma (np.ndarray): N x 1 or Scalar sigma used for `d_hat` computation.</span>

<span class="sd">        noise (np.ndarray): N x D x D of local covariance matrices on `X`.</span>

<span class="sd">        npts (np.ndarray): N x 1 number of points generated for each point in `X`.</span>

<span class="sd">        random_points (np.ndarray): M x D random points generated around X.</span>

<span class="sd">        mgc_kernel (np.ndarray): M x M kernel matrix of `Y` through data over `s_hat`.</span>

<span class="sd">        mgc_diffusion_operator (np.ndarray): M x M markov matrix of `mgc_kernel`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Initializing SUGAR&#39;</span><span class="p">)</span>
    <span class="c1"># [data, params] = init(data, varagin{:})</span>

    <span class="n">dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Obtaining Degree Estimate&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sparsity_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">degree_sigma</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">degree_sigma</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">degree_k</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">degree_a</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="n">degree_fac</span><span class="p">,</span>
        <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;d_hat: </span><span class="si">{</span><span class="n">d_hat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;s_hat: </span><span class="si">{</span><span class="n">s_hat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;degree_sigma: </span><span class="si">{</span><span class="n">degree_sigma</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">noise_cov</span> <span class="o">==</span> <span class="s1">&#39;knn&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Local Covariance estimation&#39;</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">noise_k</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">noise_cov</span> <span class="o">=</span> <span class="n">noise</span>
    
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Estimating number of points to generate&#39;</span><span class="p">)</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">numpts</span><span class="p">(</span>
        <span class="n">d_hat</span><span class="p">,</span> <span class="n">noise_cov</span><span class="o">=</span><span class="n">noise_cov</span><span class="p">,</span> <span class="n">kernel_sigma</span><span class="o">=</span><span class="n">degree_sigma</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span>
        <span class="n">equalize</span><span class="o">=</span><span class="n">equalize</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="n">suppress</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating points&#39;</span><span class="p">)</span>
    <span class="n">random_points</span><span class="p">,</span> <span class="n">out_labels</span> <span class="o">=</span> <span class="n">generate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">noise_cov</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mgc_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Diffusing points via MGC Magic&#39;</span><span class="p">)</span>
        <span class="n">Y</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="n">mgc_magic</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">random_points</span><span class="p">,</span> 
            <span class="n">s_hat</span><span class="o">=</span><span class="n">s_hat</span><span class="p">,</span>  <span class="n">sigma</span><span class="o">=</span><span class="n">mgc_sigma</span><span class="p">,</span> 
            <span class="n">a</span><span class="o">=</span><span class="n">mgc_a</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">mgc_k</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">mgc_t</span><span class="p">,</span>
            <span class="n">fac</span><span class="o">=</span><span class="n">mgc_fac</span><span class="p">,</span> <span class="n">magic_rescale</span><span class="o">=</span><span class="n">magic_rescale</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
        <span class="p">)</span>
        <span class="k">pass</span>
    <span class="c1"># NOTE: (@Jay) assumed that this was there for debugging purposes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">random_points</span>
        <span class="n">mgc_kernel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">Y</span><span class="p">,</span> <span class="n">out_labels</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">random_points</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate_imbalanced_circle" class="doc_header"><code>generate_imbalanced_circle</code><a href="https://github.com/KrishnaswamyLab/sk_sugar/sk_sugar/core.py#L927" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate_imbalanced_circle</code>(<strong><code>n_points</code></strong>:<code>int</code>=<em><code>100</code></em>, <strong><code>n_total</code></strong>:<code>int</code>=<em><code>10000</code></em>, <strong><code>weight</code></strong>:<code>float</code>=<em><code>1.2</code></em>)</p>
</blockquote>
<h2 id="Arugments:">Arugments:<a class="anchor-link" href="#Arugments:"> </a></h2>
<pre><code>n_points (int): number of points to sample from unit circle. Defaults to `100`.

n_total (int): number of points to generate uniformly on the unit circle. Defaults ot `10000`.

weight (float): weight modifier for how much to emphasize the x coordinate on the unit circle.
    Defaults to `1.2`. Setting this to `1` results in almost no points on the lefthand side of
    the circle. Setting it to `2` results in a more uniform balance.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>points (np.ndarray): 2 X `n_points` array of the points on the unit circle.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># @jit(parallel=True, forceobj=True)</span>
<span class="k">def</span> <span class="nf">generate_imbalanced_circle</span><span class="p">(</span>
    <span class="n">n_points</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_total</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> 
    <span class="n">weight</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">1.2</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Arugments:</span>
<span class="sd">    ----------</span>
<span class="sd">        n_points (int): number of points to sample from unit circle. Defaults to `100`.</span>

<span class="sd">        n_total (int): number of points to generate uniformly on the unit circle. Defaults ot `10000`.</span>
<span class="sd">        </span>
<span class="sd">        weight (float): weight modifier for how much to emphasize the x coordinate on the unit circle.</span>
<span class="sd">            Defaults to `1.2`. Setting this to `1` results in almost no points on the lefthand side of </span>
<span class="sd">            the circle. Setting it to `2` results in a more uniform balance.</span>

<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        points (np.ndarray): 2 X `n_points` array of the points on the unit circle.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_total</span><span class="p">),</span> <span class="p">))</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">pnts</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span>
        <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
            <span class="n">weights</span><span class="o">=</span><span class="n">weight</span><span class="o">+</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> 
            <span class="n">k</span><span class="o">=</span><span class="n">n_points</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">pnts</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pnts</span> <span class="o">=</span> <span class="n">generate_imbalanced_circle</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pnts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pnts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&lt;matplotlib.collections.PathCollection at 0x7feb006df850&gt;</pre>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pnts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;points.csv&#39;</span><span class="p">),</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">Y</span><span class="p">,</span> <span class="n">out_labels</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">random_points</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="n">sugar</span><span class="p">(</span>
    <span class="n">pnts</span><span class="p">,</span> 
    <span class="n">labels</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">noise_cov</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">noise_k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">sparsity_idx</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">degree_sigma</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">degree_k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">degree_a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">degree_fac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mgc_t</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">mgc_sigma</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">mgc_k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">mgc_a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">mgc_fac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/tmp/ipykernel_10384/3004691637.py:1: RuntimeWarning: covariance is not positive-semidefinite.
  Y, out_labels, d_hat, s_hat, sigma, noise, npts, random_points, mgc_kernel, mgc_diffusion_operator = sugar(
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pnts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pnts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&lt;matplotlib.collections.PathCollection at 0x7feb00e291c0&gt;</pre>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>


