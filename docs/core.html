---

title: core


keywords: fastai
sidebar: home_sidebar

summary: "API details. See docs for now."
description: "API details. See docs for now."
nb_path: "00_core.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 00_core.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="validate_sigma" class="doc_header"><code>validate_sigma</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L40" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>validate_sigma</code>(<strong><code>sigma</code></strong>:<code>~SigmaType</code>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"knn"`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>None</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">VALID_SIGMAS</span> <span class="o">=</span> <span class="s1">&#39;minmax median std knn&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="n">SigmaType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;SigmaType&#39;</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;minimax&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;knn&quot;</span><span class="p">],</span> <span class="n">Callable</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">validate_sigma</span><span class="p">(</span>
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="p">,</span> 
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;knn&quot;`.</span>
<span class="sd">            </span>
<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">is_known</span> <span class="o">=</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">VALID_SIGMAS</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;sigma (</span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s1">) is </span><span class="si">{</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">is_known</span> <span class="k">else</span> <span class="s2">&quot;not &quot;</span><span class="si">}</span><span class="s1">known or callable.</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="sa">f</span><span class="s1">&#39;known sigmas include </span><span class="si">{</span><span class="n">VALID_SIGMAS</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_known</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="gauss_kernel" class="doc_header"><code>gauss_kernel</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L78" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>gauss_kernel</code>(<strong><code>data1</code></strong>:<code>ndarray</code>, <strong><code>data2</code></strong>:<code>ndarray</code>, <strong><code>sigma</code></strong>:<code>~SigmaType</code>=<em><code>'knn'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/gauss_kernel.m

- compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927

- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data1 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

data2 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"knn"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian
    kernel.

fac (int): Rescale kernel bandwidth. Defaults to `1`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>K (np.ndarray): kernel over data1, data2

sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">gauss_kernel</span><span class="p">(</span>
    <span class="n">data1</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">data2</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/gauss_kernel.m</span>

<span class="sd">        - compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>
<span class="sd">        </span>
<span class="sd">        - `a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data1 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        data2 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;knn&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        fac (int): Rescale kernel bandwidth. Defaults to `1`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        K (np.ndarray): kernel over data1, data2</span>

<span class="sd">        sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">validate_sigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
    
    <span class="n">D</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
        <span class="n">min_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">15</span><span class="p">))</span>
        <span class="n">eps_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">min_dev</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps_val</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>        

    <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;std&#39;</span><span class="p">:</span>
        <span class="c1"># sigma = std(mean(D))</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;knn&#39;</span><span class="p">:</span>
        <span class="n">knn_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="c1"># sigma = knn_dist(k+1,:);</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">knn_dist</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">fac</span>

    <span class="c1"># K = bsxfun(@rdivide, D, sigma);</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    
    <span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    
    <span class="k">return</span> <span class="n">K</span><span class="p">,</span> <span class="n">sigma</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">data2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># data2=data1</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">VALID_SIGMAS</span><span class="p">:</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sigma=</span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">ax</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAV0AAAEICAYAAAD8yyfzAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/MnkTPAAAACXBIWXMAAAsTAAALEwEAmpwYAAATIElEQVR4nO3df/BldX3f8efLlR/iGrHRUN1FIc36Y5tEqumaNr+IGF2MhjTTToAYMgzt1k5IdKbTiNoabSeJGfJDO5ISgsSxtjAx2kLMTtAQkY74YyEisPxIViTsN4hkJRYRlP1+77t/3Iu9ufnuvd8f955z79nng/kM997zuee8z8K+v5/v+3zO+aSqkCQ140ltByBJRxOTriQ1yKQrSQ0y6UpSg0y6ktQgk64kNcik20FJ3pLk8rbjmJaunY+ObnGeriQ1x5GuJDXIpLvgkrwpyV8n+VqSu5OckeTtST4w1Oe8JH+V5CtJ/lOSe5O8YrDt7Uk+mOQDg33cluT5Sd6c5MEkB5O8cmhf5ye5c9D3niT/dgMxn55kKckvDY7xpSQ/meTVSf4iyUNJ3jLU/1vnk+SUJJXk55Lcl+RQkreO9J3K+Qz+bD+d5MmD9/8uyf4kx6/3nKUnmHQXWJIXABcC/7Sqnga8Crh3pM9O4HeAnwGeDTwd2Dayq9cC/x14BvA54Fr6/29sA/4z8LtDfR8EXgN8G3A+8NtJXjI41nOTfHVMO3doP/8QOH5wjLcBvwe8Dngp8EPA25J855jT/0HgBcAZg74vmvb5ABcDjwP/MckO4FeB11XVN8bEJY1XVbYFbcB30U8arwCOGfr87cAHBq/fBlw5tO0E+onkFUN9Pza0/bXAI8CWwfunAQWceIQY/jfwhnXGfTrw2CrHeNlQn5uBn1zlfE4Z9N0+1PezwNmzOJ/B8R4C7gTe3PZ/c9viN0e6C6yqDgBvpJ9oHkxyVZLnjHR7DnBw6DuPAl8Z6fPlodePAYeqamXoPcBWgCRnDn7lfijJV4FXA8/cQPhfWeUYo3FsHfP9B4ZePzrSd2rnU1X3Ah+nn3wvGX9K0mQm3QVXVf+zqn4QeB79Edyvj3T5ErD9iTdJngJ8+0aOleQ44EPAbwAnVdWJwF4gg+3PTfLImPYzGznurEw6n0GfVwP/DLiOfrlB2pQntx2ANm5Q090GfBL4Bv1R3OgP0j8EPp3knwM3Ae9gKKms07HAccDfAMtJzgReCdwOUFX3MX50Om/Gnk+SZwLvBS4APgPcluTqqtrbUrzqAEe6i+044J3AIfq/bn8H8JbhDlW1H/gF4Cr6o96v0a8Df3O9B6uqrwG/CPwB8LfAucA1Gw+/XWs4n8uAq6tqb1V9hX7yvTzJhn5TkMCbI446SbYCXwV2VNUXWw5HOuo40j0KJHltkhOSPJV+/fI2RqaWSWqGSffocBZw/6DtoD+9yl9xpBZYXpCkBjnSlaQGzXzK2OFD93RyKN37cveuQfVuvaHtEGbi8J/e2HYIU3fgoye0HcJMvOTg1Rudzvgt68k5xzzzOzd9vPVynq6kbumtTO7TIpOupG6pXtsRjGXSldQtPZOuJDWmHOlKUoNWltuOYCyTrqRu8UKaJDXI8oIkNcgLaZLUHC+kSVKTHOlKUoNWDrcdwVgmXUndYnlBkhpkeUGSGuRIV5Ia5EhXkppTPS+kSVJzHOlKUoOs6UpSg3zgjSQ1aNFHukleCJwFbAMKuB+4pqrunHFskrR+c17THbsEe5I3AVcBAT4L7Bu8vjLJRWO+tyfJTUluuvz9V04zXkkab2V57a0Fk0a6FwD/uKr+zhyMJL8F7AfeudqXquoy4DLo7hLskubUnI90JyXdHvAc4K9GPn/2YJskzZWqxb6Q9kbguiR/CRwcfPZc4LuAC2cYlyRtzCKPdKvqT5I8H9hF/0JagCVgX837jxNJR6dFn71Q/cewf7qBWCRp8xZ5pCtJC8cl2CWpQYteXpCkhWJ5QZIaZNKVpAZZXpCkBnkhTZIaZHlBkhpkeUGSGuRIV5IaZNKVpAbVfD9NduxDzCVp4Swvr71NkGR3kruTHFht4YYkz0jyv5LcmuSzSb570j5NupK6pXprb2Mk2QJcApwJ7ATOSbJzpNtbgFuq6nuB84B3TwrPpCupW3q9tbfxdgEHquqeqnqc/tJlZ4302QlcB1BVdwGnJDlp3E5NupK6pWrNbXg9x0HbM7Snbfz/xRug/yzxbSNH+zzwUwBJdgHPA7aPC88LaZK6ZR2zF4bXc1xFVvvKyPt3Au9OcgtwG/A5YGyxeOZJt/flL876EK3ofekv2w5h6mrp4OROC+ixLxye3GnBHDz81LZDmImXTGMn05sytgScPPR+O3D/cIeqehg4HyBJgC8O2hE50pXUKbUytZXE9gE7kpwK/DVwNnDucIckJwKPDmq+/xq4YZCIj8ikK6lbpjTSrarlJBcC1wJbgCuqan+S1w+2Xwq8CHh/khXgDuCCSfs16Urqlik+e6Gq9gJ7Rz67dOj1p4Ad69mnSVdSt/Tm+440k66kbvHZC5LUoOldSJsJk66kbnGkK0kNsqYrSQ1y5QhJapAjXUlqTlnTlaQGOXtBkhpkeUGSGmR5QZIa5EhXkhrklDFJapAjXUlqTi07e0GSmuNIV5IaZE1Xkho05yPdJ230i0nOH7PtW2vJX/7Bj2z0EJK0btWrNbc2bGak+w7g91fbMLyW/Df3XzffP3YkdcsiX0hLcuuRNgEnTT8cSdqkOS8vTBrpngS8Cvjbkc8D3DiTiCRpMxY86X4E2FpVt4xuSHL9LAKSpM2oWuCkW1UXjNl27vTDkaRNWvCRriQtFpOuJDWnlr05QpKaM98516QrqVvauulhrUy6krrFpCtJDbK8IEnNsbwgSQ2qZZOuJDXH8oIkNWfOn2Fu0pXUMSZdSWrOvI90N7xyhCTNo1pee5skye4kdyc5kOSiVbY/PckfJfl8kv3jVtR5gklXUqdUb+1tnCRbgEuAM4GdwDlJdo50+3ngjqp6MXA68JtJjh23X5OupE6ZVtIFdgEHquqeqnocuAo4a/RwwNOSBNgKPASMHUPPvKbbu/WGWR+iFbV0sO0Qpu4bN36h7RBm4sBdz2o7hKm7+fi0HcJMjGa0Dam1/9kk2QPsGfrossEajwDbgOG/6EvAy0Z28R7gGuB+4GnAT1eNT+deSJPUKeu5kDa8iO4qVsveo3devAq4BXg58I+AjyX5P1X18JGOaXlBUqdUL2tuEywBJw+9305/RDvsfODD1XcA+CLwwnE7NelK6pTeStbcJtgH7Ehy6uDi2Nn0SwnD7gPOAEhyEvAC4J5xO7W8IKlTpjVPt6qWk1wIXAtsAa6oqv1JXj/YfinwX4D3JbmNfjniTVV1aNx+TbqSOmUNZYO176tqL7B35LNLh17fD7xyPfs06UrqlDlfgd2kK6lbpjnSnQWTrqROWcMFslaZdCV1iiNdSWpQreOOtDaYdCV1yrw/2tGkK6lTeo50Jak5lhckqUHOXpCkBjl7QZIaZE1XkhpkTVeSGuSzFySpQZYXJKlBvTm/kDZx5YgkL0xyRpKtI5/vnl1YkrQxvcqaWxvGJt0kvwhcDfwCcHuS4cU6f3XM9/YkuSnJTe+97ubpRCpJa1CVNbc2TCov/BvgpVX1SJJTgD9MckpVvZvVV8oE/u4Km49d+ctzXtaW1CWLXtPdUlWPAFTVvUlOp594n8eYpCtJbZn3Ud6kmu4DSU574s0gAb8GeCbwPTOMS5I2ZKX3pDW3Nkw66nnAA8MfVNVyVZ0H/PDMopKkDeqto7VhbHmhqpbGbPvk9MORpM2pOa98Ok9XUqf05ryoa9KV1Ck9R7qS1BzLC5LUoBWTriQ1Z87XpTTpSuoWk64kNciariQ1aM6f7GjSldQtThmTpAattB3ABCZdSZ3SiyNdSWrMnN8FbNKV1C1OGZOkBs377IV2nuIrSTOyQtbcJkmyO8ndSQ4kuWiV7f8hyS2DdnuSlST/YNw+TbqSOqWXtbdxkmwBLgHOBHYC5yTZOdynqi6uqtOq6jTgzcAnquqhcfudeXnh8J/eOOtDtOKxLxxuO4SpO3DXs9oOYSauO+64tkOYuusPPzC501FqijXdXcCBqroHIMlVwFnAHUfofw5w5aSdOtKV1Cm1jpZkT5KbhtqeoV1tAw4OvV8afPb3JDkB2A18aFJ8XkiT1CnruZBWVZcBlx1h82p7OtKMtNcCn5xUWgCTrqSOmWJ5YQk4eej9duD+I/Q9mzWUFsDygqSOWcna2wT7gB1JTk1yLP3Ees1opyRPB34EuHot8TnSldQp0xrpVtVykguBa4EtwBVVtT/J6wfbLx10/RfAR6vq62vZr0lXUqdM8460qtoL7B357NKR9+8D3rfWfZp0JXWKz16QpAbN+23AJl1JneIDbySpQT7EXJIaZHlBkhpkeUGSGuTsBUlqUG/O065JV1KneCFNkhpkTVeSGuTsBUlqkDVdSWrQfKdck66kjln4mm6SXUBV1b7BSpi7gbsGjzyTpLmyMudj3bErRyT5ZeC/Av8tya8B7wG2AhcleeuY731rsbffv2tpqgFL0ji9dbQ2TBrp/kvgNOA44AFge1U9nORi4DPAr6z2peHF3h6+4Mfm+8eOpE5Z9Atpy1W1Ajya5AtV9TBAVT2WZN5LJ5KOQvOdcicn3ceTnFBVjwIvfeLDwUJsJl1Jc2feE9OkpPvDVfVNgKoaPpdjgJ+bWVSStEHzfiFtbNJ9IuGu8vkh4NBMIpKkTVj0mq4kLZT5TrkmXUkd40hXkhq06BfSJGmhlCNdSWrOQs9ekKRFY3lBkhrUK0e6ktSY+U65Jl1JHeOUMUlqkLMXJKlByyZdSWqOI11JapBTxiSpQeWUMUlqzlE/e+HAR0+Y9SFacfDwU9sOYepuPj5thzAT1x9+oO0Qpu7Gv7mr7RDm1jRvA06yG3g3sAW4vKreuUqf04F30V/c4VBV/ci4fTrSldQp0xrpJtkCXAL8GLAE7EtyTVXdMdTnROB3gN1VdV+S75i037FLsEvSoqmqNbcJdgEHquqeqnocuAo4a6TPucCHq+q+wbEfnLRTk66kTumtoyXZk+SmobZnaFfbgIND75cGnw17PvCMJNcnuTnJeZPis7wgqVPWM0+3qi4DLjvC5tUucozu/Mn0V0o/A3gK8Kkkn66qvzjSMU26kjplirMXloCTh95vB+5fpc+hqvo68PUkNwAvBo6YdC0vSOqUleqtuU2wD9iR5NQkxwJnA9eM9Lka+KEkT05yAvAy4M5xO3WkK6lTpnUbcFUtJ7kQuJb+lLErqmp/ktcPtl9aVXcm+RPgVvpl4sur6vZx+zXpSuqUaT7EvKr2AntHPrt05P3FwMVr3adJV1KnzPf9aCZdSR1z1N8GLElNMulKUoPWMCuhVSZdSZ3iQ8wlqUE+T1eSGmRNV5Ia5EhXkhq0MuerpJl0JXXKNO9ImwWTrqROcfaCJDVo3ke66360Y5L3zyIQSZqGWsc/bRg70k0y+uzIAD86WIyNqvqJI3xvD7AH4K0nfi8/tfWUTQcqSWsx7yPdSeWF7cAdwOX0H94T4PuA3xz3peElMP785LPm+09AUqfM+23Ak8oL3wfcDLwV+L9VdT3wWFV9oqo+MevgJGm9Frq8UFU94LeTfHDw7y9P+o4ktanmfKS7pgRaVUvAv0ry48DDsw1JkjauU7cBV9UfA388o1gkadO8DViSGtSpka4kzbuVXgdqupK0KLwNWJIaZE1XkhpkTVeSGuRIV5Ia5IU0SWqQ5QVJapDlBUlq0KI/2lGSForzdCWpQY50JalBvS482lGSFoUX0iSpQSZdSWrQfKdcyLz/VFiPJHsGi2J2ShfPq4vnBN08ry6eU5smLUy5aPa0HcCMdPG8unhO0M3z6uI5taZrSVeS5ppJV5Ia1LWk29W6UxfPq4vnBN08ry6eU2s6dSFNkuZd10a6kjTXTLqS1KBOJN0ku5PcneRAkovajmcaklyR5MEkt7cdyzQlOTnJx5PcmWR/kje0HdNmJTk+yWeTfH5wTu9oO6ZpSrIlyeeSfKTtWLpg4ZNuki3AJcCZwE7gnCQ7241qKt4H7G47iBlYBv59Vb0I+H7g5zvw3+ubwMur6sXAacDuJN/fbkhT9QbgzraD6IqFT7rALuBAVd1TVY8DVwFntRzTplXVDcBDbccxbVX1par688Hrr9H/y7yt3ag2p/oeGbw9ZtA6cYU6yXbgx4HL246lK7qQdLcBB4feL7Hgf4mPFklOAf4J8JmWQ9m0wa/gtwAPAh+rqoU/p4F3Ab8EzPfzEhdIF5JuVvmsE6OMLkuyFfgQ8MaqerjteDarqlaq6jRgO7AryXe3HNKmJXkN8GBV3dx2LF3ShaS7BJw89H47cH9LsWgNkhxDP+H+j6r6cNvxTFNVfRW4nm7U438A+Ikk99Iv2708yQfaDWnxdSHp7gN2JDk1ybHA2cA1LcekI0gS4L3AnVX1W23HMw1JnpXkxMHrpwCvAO5qNagpqKo3V9X2qjqF/t+rP6uq17Uc1sJb+KRbVcvAhcC19C/K/EFV7W83qs1LciXwKeAFSZaSXNB2TFPyA8DP0h813TJor247qE16NvDxJLfSHwR8rKqcXqVVeRuwJDVo4Ue6krRITLqS1CCTriQ1yKQrSQ0y6UpSg0y6ktQgk64kNej/ARhNc46INtapAAAAAElFTkSuQmCC"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="degrees" class="doc_header"><code>degrees</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L175" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>degrees</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>sigma</code></strong>:<code>~SigmaType</code>=<em><code>'std'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/degrees.m

- compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927

- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"std"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian
    kernel.

fac (int): Rescale kernel bandwidth. Defaults to `1`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>d_hat (np.ndarray): N x 1 vector of the degree at each point in data of size N

s_hat (np.ndarray): N x 1 vector of the sparsity at each point,
    `s_hat=np.divide(1, d_hat)`

sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">degrees</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/degrees.m</span>

<span class="sd">        - compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>
<span class="sd">        </span>
<span class="sd">        - `a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;std&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        fac (int): Rescale kernel bandwidth. Defaults to `1`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        d_hat (np.ndarray): N x 1 vector of the degree at each point in data of size N</span>

<span class="sd">        s_hat (np.ndarray): N x 1 vector of the sparsity at each point, </span>
<span class="sd">            `s_hat=np.divide(1, d_hat)`</span>
<span class="sd">        </span>
<span class="sd">        sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">validate_sigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="n">fac</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
    <span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">d_hat</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">s_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">sigma</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">degrees</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([1., 1., 1., 1., 1.]), array([1., 1., 1., 1., 1.]), 3.7416573867739413)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="local_covariance" class="doc_header"><code>local_covariance</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L240" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>local_covariance</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/local_covariance.m

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"std"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>local_cov (np.ndarray):  N-length cell of local covariance matrices of the Gaussian
    generated noise.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">local_covariance</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/local_covariance.m</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;std&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        local_cov (np.ndarray):  N-length cell of local covariance matrices of the Gaussian</span>
<span class="sd">            generated noise. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">local_cov</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">neigh</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">neigh</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">local_cov</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">local_cov</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data1</span><span class="p">,</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]]),
 array([[[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]]]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data2</span><span class="p">,</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[0., 1., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]]),
 array([[[ 2.5 , -0.75,  2.5 ,  2.5 ,  2.5 ],
         [-0.75,  2.5 , -0.75, -0.75, -0.75],
         [ 2.5 , -0.75,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 , -0.75,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 , -0.75,  2.5 ,  2.5 ,  2.5 ]],
 
        [[ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ]],
 
        [[ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ]],
 
        [[ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ]],
 
        [[ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ]]]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="feature_scale" class="doc_header"><code>feature_scale</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L277" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>feature_scale</code>(<strong><code>x</code></strong>:<code>ndarray</code>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">feature_scale</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fp</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="numpts" class="doc_header"><code>numpts</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L282" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>numpts</code>(<strong><code>degree</code></strong>:<code>ndarray</code>, <strong><code>noise_cov</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>ndarray</code>]=<em><code>1</code></em>, <strong><code>kernel_sigma</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>ndarray</code>]=<em><code>1</code></em>, <strong><code>dim</code></strong>:<code>Union</code>[<code>int</code>, Literal[None]<code>\]=*</code>None<code>*, **</code>M<code>**:</code>int<code>=*</code>0<code>*, **</code>equalize<code>**:</code>bool<code>=*</code>False<code>*, **</code>suppress<code>**:</code>bool<code>=*</code>False<code>*, **</code>logger<code>**:</code>Optional<code>\[</code>Logger<code>\]=*</code>None`*)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/numpts.m

- compute the number of new points to generate around each point in a
    dataset https://arxiv.org/abs/1802.04927

- `M` (number of points to generate)
    + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`
        will negatively impact density equalization, `M &lt;&lt; N` is not recommended
        and `M &lt;&lt;&lt; N` may fail.

    + `not M and equalize`: then density equalization will not be scaled.

    + `M and not equalize`: then approximately `M` points will be generated
        according to a constant difference of max density.

    + `not M and not equalize`: then `M` is approximately N points.

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>degree (np.ndarray): Degree estimate of the N x D data in shape N x 1.


noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation.
    Accepts a scalar for a unifrom Gaussian noise variance or an array
    containing D x D local covariance matricies for Gaussian generated noise.
    Defaults to `1`.

kernel_sigma (int|float|np.ndarray): Degree estimate bandwith. A scalar for uniform
    bandwidth or an N x 1 array for adaptive bandwidth. Defaults to `1`.

dim (int): Generated noise dimension. Defaults to `D` if availible from
    `noise_cov` else required.

M (int): Number of points to generate. Can affect strength of density equalization.
    Can accept positive scalars. Defaults to `0`.

equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults
    to `False`.

suppress (bool): Enabled / disable point generation errors. Defaults to `False`.
    Deprecated.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>npts (np.ndarray): The number of points to generate at each point</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">numpts</span><span class="p">(</span>
    <span class="n">degree</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">noise_cov</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">kernel_sigma</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">dim</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">suppress</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/numpts.m</span>

<span class="sd">        - compute the number of new points to generate around each point in a </span>
<span class="sd">            dataset https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `M` (number of points to generate)</span>
<span class="sd">            + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`</span>
<span class="sd">                will negatively impact density equalization, `M &lt;&lt; N` is not recommended</span>
<span class="sd">                and `M &lt;&lt;&lt; N` may fail.</span>

<span class="sd">            + `not M and equalize`: then density equalization will not be scaled.</span>
<span class="sd">            </span>
<span class="sd">            + `M and not equalize`: then approximately `M` points will be generated</span>
<span class="sd">                according to a constant difference of max density.</span>
<span class="sd">            </span>
<span class="sd">            + `not M and not equalize`: then `M` is approximately N points.</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        degree (np.ndarray): Degree estimate of the N x D data in shape N x 1.</span>


<span class="sd">        noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation. </span>
<span class="sd">            Accepts a scalar for a unifrom Gaussian noise variance or an array </span>
<span class="sd">            containing D x D local covariance matricies for Gaussian generated noise.</span>
<span class="sd">            Defaults to `1`.</span>
<span class="sd">        </span>
<span class="sd">        kernel_sigma (int|float|np.ndarray): Degree estimate bandwith. A scalar for uniform</span>
<span class="sd">            bandwidth or an N x 1 array for adaptive bandwidth. Defaults to `1`.</span>
<span class="sd">        </span>
<span class="sd">        dim (int): Generated noise dimension. Defaults to `D` if availible from </span>
<span class="sd">            `noise_cov` else required. </span>

<span class="sd">        M (int): Number of points to generate. Can affect strength of density equalization.</span>
<span class="sd">            Can accept positive scalars. Defaults to `0`.</span>

<span class="sd">        equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults</span>
<span class="sd">            to `False`.</span>

<span class="sd">        suppress (bool): Enabled / disable point generation errors. Defaults to `False`.</span>
<span class="sd">            Deprecated.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        npts (np.ndarray): The number of points to generate at each point</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">number_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">equalize</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Density equalizaton according to scalar noise covariance...&#39;</span><span class="p">)</span>
            <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="o">-</span> <span class="n">degree</span><span class="p">)</span> <span class="o">*</span> \
                <span class="p">(</span> <span class="p">(</span><span class="n">kernel_sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">noise_cov</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">noise_cov</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Density equalizaton according to local noise covariance...&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">kernel_sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">kernel_sigma</span>
                <span class="n">number_estimate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="o">-</span> <span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> \
                            <span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> 
                    <span class="p">),</span>
                    <span class="mf">0.5</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Applying total generation constraint M.&#39;</span><span class="p">)</span>
            <span class="n">number_save</span> <span class="o">=</span> <span class="n">number_estimate</span>
            <span class="n">number_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">M</span> <span class="o">/</span> <span class="n">number_sum</span> <span class="o">&lt;</span> <span class="mf">1e-1</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">M</span> <span class="o">/</span> <span class="n">number_sum</span> <span class="o">*</span> <span class="mi">100</span><span class="si">}</span><span class="s1">% of equalized total. &#39;</span>
                    <span class="s1">&#39;Output will reflecct equalization. Increased M suggested.&#39;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">number_estimate</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-17</span><span class="p">)</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating without density equalization&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No M supplied, M = N&#39;</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="o">-</span> <span class="n">degree</span><span class="p">)</span>
        <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">number_estimate</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e17</span><span class="p">)</span>

        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Point generation estimate &lt; 0, either provide/increase M or decrease noise_cov.&#39;</span><span class="p">)</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Point generation estimate &gt; 1e4, either provide/decrease M or increase noise_cov.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">npts</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate" class="doc_header"><code>generate</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L401" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>npts</code></strong>:<code>ndarray</code>, <strong><code>noise_cov</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>ndarray</code>], <strong><code>labels</code></strong>:<code>list</code>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/generate.m

- compute the number of new points to generate around each point in a
    dataset https://arxiv.org/abs/1802.04927

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


npts (np.ndarray): Number of points to generate around each point in data,
    with shape N x 1.

noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation.
    Accepts a scalar for a unifrom Gaussian noise variance or an array
    containing D x D local covariance matricies for Gaussian generated noise.

labels (list): Labels to add to new points

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>random_points (np.ndarray): Noisy generated points with shape `np.sum(npts) x D`.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">generate</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">npts</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">noise_cov</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
    <span class="n">labels</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/generate.m</span>

<span class="sd">        - compute the number of new points to generate around each point in a </span>
<span class="sd">            dataset https://arxiv.org/abs/1802.04927</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        npts (np.ndarray): Number of points to generate around each point in data,</span>
<span class="sd">            with shape N x 1.</span>
<span class="sd">           </span>
<span class="sd">        noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation. </span>
<span class="sd">            Accepts a scalar for a unifrom Gaussian noise variance or an array </span>
<span class="sd">            containing D x D local covariance matricies for Gaussian generated noise.</span>
<span class="sd">                    </span>
<span class="sd">        labels (list): Labels to add to new points</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        random_points (np.ndarray): Noisy generated points with shape `np.sum(npts) x D`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    

    <span class="n">rep_centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rep_cov</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">labels_out</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span> <span class="c1"># constant cov, no need to replicate cov.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="c1"># replicate data[i] to make npts[i] centers for mvnrnd</span>
            <span class="n">new_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">rep_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_center</span><span class="p">)</span><span class="c1"># = [rep_centers, new_center]</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">new_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">labels_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_out</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">]</span>
        <span class="c1"># generate</span>
        <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
            <span class="n">rep_centers</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">noise_cov</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="c1"># replicate centers npts[i] times</span>
            <span class="n">new_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="c1"># new_center = np.matlib.repmat(row.T, 1, int(npts[i]))</span>
            
            <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">new_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">labels_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_out</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">]</span>
            
            <span class="c1"># rep_centers = [rep_centers, new_center]</span>
            <span class="n">rep_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_center</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># replicate the covariance matrix     </span>
                <span class="n">rep_cov</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> 
                                  
                <span class="c1"># if i == 0:</span>
                <span class="c1">#     rep_cov = np.tile(noise_cov[i], (1, 1, npts[i]))                      </span>
                <span class="c1"># else:</span>
                <span class="c1">#     rep_cov = np.concatenate(</span>
                <span class="c1">#         (</span>
                <span class="c1">#             rep_cov,</span>
                <span class="c1">#             np.tile(noise_cov[i], (1, 1, npts[i]))</span>
                <span class="c1">#         ),</span>
                <span class="c1">#         axis=2                    </span>
                <span class="c1">#     )        </span>

        <span class="n">rep_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rep_cov</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">noise_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rep_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rep_centers</span><span class="p">)</span>

        <span class="n">random_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rep_centers</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">random_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">rep_cov</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="c1"># random_points = np.apply_along_axis(</span>
        <span class="c1">#     np.random.multivariate_normal, 0, </span>
        <span class="c1">#     np.array(rep_centers, dtype=object).T, rep_cov</span>
        <span class="c1"># ) </span>
        <span class="c1"># random_points = np.random.multivariate_normal(</span>
        <span class="c1">#     np.array(rep_centers, dtype=object).T, rep_cov</span>
        <span class="c1"># )</span>
        <span class="c1"># random_points = np.random.Generator.multivariate_normal(</span>
        <span class="c1">#     np.array(rep_centers, dtype=object).T, rep_cov</span>
        <span class="c1"># )</span>
        <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">random_points</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">random_points</span><span class="p">,</span> <span class="n">labels_out</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="magic" class="doc_header"><code>magic</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L506" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>magic</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>kernel</code></strong>:<code>ndarray</code>, <strong><code>t</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>rescale</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/magic.m

- MAGIC (Markov Affinity based Gaussian Imputation of Cells) see:
    + https://www.biorxiv.org/content/early/2017/02/25/111591
    + https://arxiv.org/abs/1802.04927

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


kernel (np.ndarray): N x N kernel or affinity matrix.

t (int): Time steps to apply MAGIC for. Controls low pass filter cutoff.
    Defaults to `1`.

rescale (bool): Rescale 95th percentile of imputed data to match original
    data. Defaults to `True`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>data_imputed (np.ndarray): M x D Data points imputed via MAGIC using kernel.

diffusion_operator (np.ndarray): M x M Markov matrix built from kernel.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">magic</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">kernel</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">t</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rescale</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/magic.m</span>

<span class="sd">        - MAGIC (Markov Affinity based Gaussian Imputation of Cells) see:</span>
<span class="sd">            + https://www.biorxiv.org/content/early/2017/02/25/111591</span>
<span class="sd">            + https://arxiv.org/abs/1802.04927</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        kernel (np.ndarray): N x N kernel or affinity matrix.</span>
<span class="sd">           </span>
<span class="sd">        t (int): Time steps to apply MAGIC for. Controls low pass filter cutoff.</span>
<span class="sd">            Defaults to `1`.</span>
<span class="sd">                    </span>
<span class="sd">        rescale (bool): Rescale 95th percentile of imputed data to match original</span>
<span class="sd">            data. Defaults to `True`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        data_imputed (np.ndarray): M x D Data points imputed via MAGIC using kernel.</span>

<span class="sd">        diffusion_operator (np.ndarray): M x M Markov matrix built from kernel.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span>
        <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Data does not match kernel size&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># build diffusion operator</span>
    <span class="n">diffusion_degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span> 
    <span class="n">diffusion_degree</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">diffusion_degree</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">diffusion_operator</span> <span class="o">=</span> <span class="n">diffusion_degree</span> <span class="o">*</span> <span class="n">kernel</span>

    <span class="n">data_imputed</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">data_imputed</span> <span class="o">=</span> <span class="n">diffusion_operator</span> <span class="o">*</span> <span class="n">data_imputed</span>
    
    <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
        <span class="n">data_imputed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
            <span class="n">data_imputed</span><span class="p">,</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">95</span><span class="p">),</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data_imputed</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">data_imputed</span><span class="p">,</span> <span class="n">diffusion_operator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="mgc_magic" class="doc_header"><code>mgc_magic</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L573" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>mgc_magic</code>(<strong><code>X</code></strong>:<code>ndarray</code>, <strong><code>Y</code></strong>:<code>ndarray</code>, <strong><code>s_hat</code></strong>:<code>ndarray</code>, <strong><code>sigma</code></strong>:<code>~SigmaType</code>=<em><code>'knn'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>t</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>magic_rescale</code></strong>:<code>bool</code>=<em><code>1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/mgc_magic.m

- MGC_MAGIC (Measure-based Gaussian Correlation Kernel w/ MAGIC):
    + https://arxiv.org/abs/1802.04927

- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

- `t`
    + `t=0`: [`mgc_magic`](/sugar/core.html#mgc_magic) is not called
    + `t&gt;0`: applies [`mgc_magic`](/sugar/core.html#mgc_magic) steps of diffusion.

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>X (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

Y (np.ndarray): M x D Data matrix. N rows are measurements, D columns are features.

s_hat (np.ndarray): M x 1 measure vector. M entries correspond to measures on the rows of Y.

sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"std"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian
    kernel.

fac (int): Rescale kernel bandwidth. Defaults to `1`.

t (int): Apply MGC MAGIC to diffuse new points. If less than `0` [`mgc_magic`](/sugar/core.html#mgc_magic)
    is not called. Defaults to `1`.

magic_rescale (bool): Rescale 95th percentile of imputed data to match original
    data. Defaults to `True`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>new_data (np.ndarray): M x D New points corrected using MGC MAGIC through X.

mgc_kernel (np.ndarray): M x M MGC kernel built over Y through X via `s_hat`.

mgc_diffusion_operator (np.ndarray): M x M row stochastic MGC
    markov matrix / diffusion operator</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">mgc_magic</span><span class="p">(</span>
    <span class="n">X</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">Y</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">s_hat</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span> <span class="o">=</span> <span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">fac</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/mgc_magic.m</span>

<span class="sd">        - MGC_MAGIC (Measure-based Gaussian Correlation Kernel w/ MAGIC): </span>
<span class="sd">            + https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">        - `a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">        - `t`</span>
<span class="sd">            + `t=0`: `mgc_magic` is not called</span>
<span class="sd">            + `t&gt;0`: applies `mgc_magic` steps of diffusion. </span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        X (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>
<span class="sd">        </span>
<span class="sd">        Y (np.ndarray): M x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        s_hat (np.ndarray): M x 1 measure vector. M entries correspond to measures on the rows of Y.</span>

<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;std&quot;`.</span>

<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        fac (int): Rescale kernel bandwidth. Defaults to `1`.</span>

<span class="sd">        t (int): Apply MGC MAGIC to diffuse new points. If less than `0` `mgc_magic`</span>
<span class="sd">            is not called. Defaults to `1`.</span>
<span class="sd">                    </span>
<span class="sd">        magic_rescale (bool): Rescale 95th percentile of imputed data to match original</span>
<span class="sd">            data. Defaults to `True`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        new_data (np.ndarray): M x D New points corrected using MGC MAGIC through X.</span>

<span class="sd">        mgc_kernel (np.ndarray): M x M MGC kernel built over Y through X via `s_hat`.</span>

<span class="sd">        mgc_diffusion_operator (np.ndarray): M x M row stochastic MGC </span>
<span class="sd">            markov matrix / diffusion operator</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">Y</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;mgc_magic was passed t=0, no mgc_magic was performed&#39;</span><span class="p">)</span>
    <span class="n">new_to_old</span><span class="p">,</span> <span class="n">sigma_nto</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fac</span><span class="p">)</span>
    <span class="n">old_to_new</span><span class="p">,</span> <span class="n">sigma_otn</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fac</span><span class="p">)</span>

    <span class="n">new_to_old_sparsity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_to_old</span><span class="p">):</span>
        <span class="n">new_to_old_sparsity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    
    <span class="n">new_to_old_sparsity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_to_old_sparsity</span><span class="p">)</span>
    <span class="c1"># new_to_old_sparsity = np.apply_along_axis(</span>
    <span class="c1">#     np.multiply, 0,</span>
    <span class="c1">#     new_to_old, s_hat</span>
    <span class="c1"># )</span>
    <span class="n">mgc_kernel</span> <span class="o">=</span> <span class="n">new_to_old_sparsity</span> <span class="o">*</span> <span class="n">old_to_new</span>
    <span class="n">mgc_kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span> <span class="p">(</span><span class="n">mgc_kernel</span> <span class="o">+</span> <span class="n">mgc_kernel</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">new_data</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="n">magic</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">magic_rescale</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="sugar" class="doc_header"><code>sugar</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L666" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>sugar</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>labels</code></strong>:<code>list</code>=<em><code>[]</code></em>, <strong><code>noise_cov</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, Literal['knn']<code>\]=*</code>'knn'<code>*, **</code>noise_k<code>**:</code>int<code>=*</code>5<code>*, **</code>sparsity_idx<code>**:</code>list<code>=*</code>[]<code>*, **</code>degree_sigma<code>**:</code>~SigmaType<code>=*</code>'std'<code>*, **</code>degree_k<code>**:</code>int<code>=*</code>5<code>*, **</code>degree_a<code>**:</code>int<code>=*</code>2<code>*, **</code>degree_fac<code>**:</code>int<code>=*</code>1<code>*, **</code>M<code>**:</code>int<code>=*</code>0<code>*, **</code>equalize<code>**:</code>bool<code>=*</code>False<code>*, **</code>mgc_t<code>**:</code>int<code>=*</code>1<code>*, **</code>mgc_sigma<code>**:</code>~SigmaType<code>=*</code>'knn'<code>*, **</code>mgc_k<code>**:</code>int<code>=*</code>5<code>*, **</code>mgc_a<code>**:</code>int<code>=*</code>2<code>*, **</code>mgc_fac<code>**:</code>int<code>=*</code>1<code>*, **</code>magic_rescale<code>**:</code>bool<code>=*</code>1<code>*, **</code>suppress<code>**:</code>bool<code>=*</code>False<code>*, **</code>logger<code>**:</code>Optional<code>\[</code>Logger<code>\]=*</code>None`*)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/sugar.m

- SUGAR (Geometry-based Data Generation)
    + https://arxiv.org/abs/1802.04927

- `degree_sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `degree_a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

- `M` (number of points to generate)
    + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`
        will negatively impact density equalization, `M &lt;&lt; N` is not recommended
        and `M &lt;&lt;&lt; N` may fail.

    + `not M and equalize`: then density equalization will not be scaled.

    + `M and not equalize`: then approximately `M` points will be generated
        according to a constant difference of max density.

    + `not M and not equalize`: then `M` is approximately N points.

- `mgc_t`
    + `mgc_t=0`: [`mgc_magic`](/sugar/core.html#mgc_magic) is not called
    + `mgc_t&gt;0`: applies [`mgc_magic`](/sugar/core.html#mgc_magic) steps of diffusion.

- `mgc_sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `mgc_a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

labels (list): N x 1 vector of classifier labels. Defaults to `[]`.

noise_cov (int|float|str): Bandwidth of Gaussian noise. Either scalar or `"knn"`.
    Defaults to `"knn"`.

noise_k (int): Neighborhood size for covariance estimation. Defaults to `5`.

sparsity_idx (list): Column indexes for sparsity estimation dimensions. If `[]`
    estimate sparsity in all dimensions. Defaults to `[]`.

degree_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to
    use or a user defined function. Valid `sigma` values include `"minmax"`, `"median"`,
    `"std"`, `"knn"`. Defaults to `"knn"`.

degree_k (int): K-nearest neighbor distance to use if `degree_sigma="knn"`. Defaults to `5`.

degree_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `degree_a=2` is the
    Gaussian kernel.

degree_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.

M (int): Number of points to generate. Can affect strength of density equalization.
    Can accept positive scalars. Defaults to `0`.

equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults
    to `False`.

mgc_t (int): Apply MGC MAGIC to diffuse new points. If less than `0` [`mgc_magic`](/sugar/core.html#mgc_magic)
    is not called. Defaults to `1`.

mgc_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to
    use or a user defined function. Valid `sigma` values include `"minmax"`, `"median"`,
    `"std"`, `"knn"`. Defaults to `"knn"`.

mgc_k (int): K-nearest neighbor distance to use if `mgc_sigma="knn"`. Defaults to `5`.

mgc_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `mgc_a=2` is the Gaussian
    kernel.

mgc_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.

magic_rescale (bool): Rescale 95th percentile of imputed data to match original
    data after MAGIC. Defaults to `True`.

suppress (bool): Enabled / disable point generation errors. Defaults to `False`.
    Deprecated.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>Y (np.ndarray): M x D New points generated by SUGAR.

out_labels (np.ndarray): M x 1 New labels corresponding to `Y`.

d_hat (np.ndarray): N x 1 Degree estimate of data.

s_hat (np.ndarray): N x 1 Sparsity estimate of data.

sigma (np.ndarray): N x 1 or Scalar sigma used for `d_hat` computation.

noise (np.ndarray): N x D x D of local covariance matrices on `X`.

npts (np.ndarray): N x 1 number of points generated for each point in `X`.

random_points (np.ndarray): M x D random points generated around X.

mgc_kernel (np.ndarray): M x M kernel matrix of `Y` through data over `s_hat`.

mgc_diffusion_operator (np.ndarray): M x M markov matrix of `mgc_kernel`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">sugar</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">labels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">noise_cov</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;knn&quot;</span><span class="p">]]</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">noise_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">sparsity_idx</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">degree_sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">degree_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">degree_a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">degree_fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mgc_t</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">mgc_sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">mgc_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">mgc_a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">mgc_fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">suppress</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/sugar.m</span>

<span class="sd">        - SUGAR (Geometry-based Data Generation)    </span>
<span class="sd">            + https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `degree_sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">        - `degree_a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">        - `M` (number of points to generate)</span>
<span class="sd">            + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`</span>
<span class="sd">                will negatively impact density equalization, `M &lt;&lt; N` is not recommended</span>
<span class="sd">                and `M &lt;&lt;&lt; N` may fail.</span>

<span class="sd">            + `not M and equalize`: then density equalization will not be scaled.</span>
<span class="sd">            </span>
<span class="sd">            + `M and not equalize`: then approximately `M` points will be generated</span>
<span class="sd">                according to a constant difference of max density.</span>
<span class="sd">            </span>
<span class="sd">            + `not M and not equalize`: then `M` is approximately N points.</span>

<span class="sd">        - `mgc_t`</span>
<span class="sd">            + `mgc_t=0`: `mgc_magic` is not called</span>
<span class="sd">            + `mgc_t&gt;0`: applies `mgc_magic` steps of diffusion. </span>

<span class="sd">        - `mgc_sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">        - `mgc_a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        labels (list): N x 1 vector of classifier labels. Defaults to `[]`.</span>
<span class="sd">        </span>
<span class="sd">        noise_cov (int|float|str): Bandwidth of Gaussian noise. Either scalar or `&quot;knn&quot;`.</span>
<span class="sd">            Defaults to `&quot;knn&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        noise_k (int): Neighborhood size for covariance estimation. Defaults to `5`.</span>

<span class="sd">        sparsity_idx (list): Column indexes for sparsity estimation dimensions. If `[]`</span>
<span class="sd">            estimate sparsity in all dimensions. Defaults to `[]`.</span>

<span class="sd">        degree_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to </span>
<span class="sd">            use or a user defined function. Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, </span>
<span class="sd">            `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to `&quot;knn&quot;`.</span>

<span class="sd">        degree_k (int): K-nearest neighbor distance to use if `degree_sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        degree_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `degree_a=2` is the </span>
<span class="sd">            Gaussian kernel.</span>
<span class="sd">        </span>
<span class="sd">        degree_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.</span>
<span class="sd">     </span>
<span class="sd">        M (int): Number of points to generate. Can affect strength of density equalization.</span>
<span class="sd">            Can accept positive scalars. Defaults to `0`.</span>

<span class="sd">        equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults</span>
<span class="sd">            to `False`.</span>

<span class="sd">        mgc_t (int): Apply MGC MAGIC to diffuse new points. If less than `0` `mgc_magic`</span>
<span class="sd">            is not called. Defaults to `1`.</span>

<span class="sd">        mgc_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to </span>
<span class="sd">            use or a user defined function. Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, </span>
<span class="sd">            `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to `&quot;knn&quot;`.</span>

<span class="sd">        mgc_k (int): K-nearest neighbor distance to use if `mgc_sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        mgc_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `mgc_a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        mgc_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.</span>
<span class="sd">                    </span>
<span class="sd">        magic_rescale (bool): Rescale 95th percentile of imputed data to match original</span>
<span class="sd">            data after MAGIC. Defaults to `True`.</span>

<span class="sd">        suppress (bool): Enabled / disable point generation errors. Defaults to `False`.</span>
<span class="sd">            Deprecated.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        Y (np.ndarray): M x D New points generated by SUGAR.</span>

<span class="sd">        out_labels (np.ndarray): M x 1 New labels corresponding to `Y`.</span>

<span class="sd">        d_hat (np.ndarray): N x 1 Degree estimate of data.</span>

<span class="sd">        s_hat (np.ndarray): N x 1 Sparsity estimate of data.</span>

<span class="sd">        sigma (np.ndarray): N x 1 or Scalar sigma used for `d_hat` computation.</span>

<span class="sd">        noise (np.ndarray): N x D x D of local covariance matrices on `X`.</span>

<span class="sd">        npts (np.ndarray): N x 1 number of points generated for each point in `X`.</span>

<span class="sd">        random_points (np.ndarray): M x D random points generated around X.</span>

<span class="sd">        mgc_kernel (np.ndarray): M x M kernel matrix of `Y` through data over `s_hat`.</span>

<span class="sd">        mgc_diffusion_operator (np.ndarray): M x M markov matrix of `mgc_kernel`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Initializing SUGAR&#39;</span><span class="p">)</span>
    <span class="c1"># [data, params] = init(data, varagin{:})</span>

    <span class="n">dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Obtaining Degree Estimate&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sparsity_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">degree_sigma</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">degree_sigma</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">degree_k</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">degree_a</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="n">degree_fac</span><span class="p">,</span>
        <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;d_hat: </span><span class="si">{</span><span class="n">d_hat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;s_hat: </span><span class="si">{</span><span class="n">s_hat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;degree_sigma: </span><span class="si">{</span><span class="n">degree_sigma</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">noise_cov</span> <span class="o">==</span> <span class="s1">&#39;knn&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Local Covariance estimation&#39;</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">noise_k</span><span class="p">)</span>
        <span class="n">noise_cov</span> <span class="o">=</span> <span class="n">noise</span>
    
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Estimating number of points to generate&#39;</span><span class="p">)</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">numpts</span><span class="p">(</span>
        <span class="n">d_hat</span><span class="p">,</span> <span class="n">noise_cov</span><span class="o">=</span><span class="n">noise_cov</span><span class="p">,</span> <span class="n">kernel_sigma</span><span class="o">=</span><span class="n">degree_sigma</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span>
        <span class="n">equalize</span><span class="o">=</span><span class="n">equalize</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="n">suppress</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating points&#39;</span><span class="p">)</span>
    <span class="n">random_points</span><span class="p">,</span> <span class="n">out_labels</span> <span class="o">=</span> <span class="n">generate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">noise_cov</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mgc_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Diffusing points via MGC Magic&#39;</span><span class="p">)</span>
        <span class="n">Y</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="n">mgc_magic</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">random_points</span><span class="p">,</span> 
            <span class="n">s_hat</span><span class="o">=</span><span class="n">s_hat</span><span class="p">,</span>  <span class="n">sigma</span><span class="o">=</span><span class="n">mgc_sigma</span><span class="p">,</span> 
            <span class="n">a</span><span class="o">=</span><span class="n">mgc_a</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">mgc_k</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">mgc_t</span><span class="p">,</span>
            <span class="n">fac</span><span class="o">=</span><span class="n">mgc_fac</span><span class="p">,</span> <span class="n">magic_rescale</span><span class="o">=</span><span class="n">magic_rescale</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
        <span class="p">)</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">random_points</span>
        <span class="n">mgc_kernel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">Y</span><span class="p">,</span> <span class="n">out_labels</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">random_points</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sugar</span><span class="p">(</span>
    <span class="n">data1</span><span class="p">,</span> 
    <span class="n">labels</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">noise_cov</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">noise_k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">sparsity_idx</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">degree_sigma</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">degree_k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">degree_a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">degree_fac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mgc_t</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">mgc_sigma</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">mgc_k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">mgc_a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">mgc_fac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],
        [ 0.        ,  8.27172637,  0.        ,  0.        ,  0.        ],
        [ 0.        ,  0.        , 26.06457027,  0.        ,  0.        ],
        [ 0.        ,  0.        ,  0.        , 39.28387375,  0.        ],
        [ 0.        ,  0.        ,  0.        ,  0.        , 12.19279492]]),
 [],
 array([1., 1., 1., 1., 1.]),
 array([1., 1., 1., 1., 1.]),
 &#39;knn&#39;,
 array([[[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]]]),
 array([1., 1., 1., 1., 1.]),
 array([[ 0.50352892,  5.29690342, 11.5198892 , 14.70309657, 19.49647106],
        [ 1.23169452,  5.54400324,  9.55393582, 16.45599675, 20.76830549],
        [ 2.03766909,  6.69355651, 11.97523195, 17.30644348, 21.96233095],
        [ 2.37781373,  6.70182635, 13.22126059, 19.29817364, 23.62218627],
        [ 2.96591215,  7.46696751, 12.24977171, 20.5330325 , 25.03408786]]),
 array([[0.00000000e+00, 6.60160908e-02, 1.62654892e-01, 4.42356417e-02,
         2.47319380e-05],
        [6.60160908e-02, 1.35335283e-01, 2.20650110e-01, 5.32929043e-02,
         9.53391858e-05],
        [1.62654892e-01, 2.20650110e-01, 6.15170009e-01, 3.93040189e-01,
         8.97743558e-02],
        [4.42356417e-02, 5.32929043e-02, 3.93040189e-01, 4.01602362e-01,
         1.41802866e-01],
        [2.47319380e-05, 9.53391858e-05, 8.97743558e-02, 1.41802866e-01,
         2.37378092e-02]]),
 array([[0.        , 0.        , 0.        , 0.        , 0.        ],
        [0.        , 0.28468281, 0.        , 0.        , 0.        ],
        [0.        , 0.        , 0.41529356, 0.        , 0.        ],
        [0.        , 0.        , 0.        , 0.38840665, 0.        ],
        [0.        , 0.        , 0.        , 0.        , 0.09293088]]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

