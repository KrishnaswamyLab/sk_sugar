---

title: core


keywords: fastai
sidebar: home_sidebar

summary: "API details. See docs for now."
description: "API details. See docs for now."
nb_path: "00_core.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 00_core.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="validate_sigma" class="doc_header"><code>validate_sigma</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L40" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>validate_sigma</code>(<strong><code>sigma</code></strong>:<code>~SigmaType</code>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"knn"`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>None</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">VALID_SIGMAS</span> <span class="o">=</span> <span class="s1">&#39;minmax median std knn&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="n">SigmaType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;SigmaType&#39;</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;minimax&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;knn&quot;</span><span class="p">],</span> <span class="n">Callable</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">validate_sigma</span><span class="p">(</span>
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="p">,</span> 
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;knn&quot;`.</span>
<span class="sd">            </span>
<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">is_known</span> <span class="o">=</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">VALID_SIGMAS</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;sigma (</span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s1">) is </span><span class="si">{</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">is_known</span> <span class="k">else</span> <span class="s2">&quot;not &quot;</span><span class="si">}</span><span class="s1">known or callable.</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="sa">f</span><span class="s1">&#39;known sigmas include </span><span class="si">{</span><span class="n">VALID_SIGMAS</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_known</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="gauss_kernel" class="doc_header"><code>gauss_kernel</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L78" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>gauss_kernel</code>(<strong><code>data1</code></strong>:<code>ndarray</code>, <strong><code>data2</code></strong>:<code>ndarray</code>, <strong><code>sigma</code></strong>:<code>~SigmaType</code>=<em><code>'knn'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/gauss_kernel.m

- compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927

- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data1 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

data2 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"knn"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian
    kernel.

fac (int): Rescale kernel bandwidth. Defaults to `1`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>K (np.ndarray): kernel over data1, data2

sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">gauss_kernel</span><span class="p">(</span>
    <span class="n">data1</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">data2</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/gauss_kernel.m</span>

<span class="sd">        - compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>
<span class="sd">        </span>
<span class="sd">        - `a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data1 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        data2 (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;knn&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        fac (int): Rescale kernel bandwidth. Defaults to `1`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        K (np.ndarray): kernel over data1, data2</span>

<span class="sd">        sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">validate_sigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
    
    <span class="n">D</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
        <span class="n">min_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">15</span><span class="p">))</span>
        <span class="n">eps_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">min_dev</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps_val</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>        

    <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;std&#39;</span><span class="p">:</span>
        <span class="c1"># sigma = std(mean(D))</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="s1">&#39;knn&#39;</span><span class="p">:</span>
        <span class="n">knn_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="c1"># sigma = knn_dist(k+1,:);</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">knn_dist</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">fac</span>

    <span class="c1"># K = bsxfun(@rdivide, D, sigma);</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    
    <span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    
    <span class="k">return</span> <span class="n">K</span><span class="p">,</span> <span class="n">sigma</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">data2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># data2=data1</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">VALID_SIGMAS</span><span class="p">:</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sigma=</span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">ax</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="degrees" class="doc_header"><code>degrees</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L175" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>degrees</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>sigma</code></strong>:<code>~SigmaType</code>=<em><code>'std'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/degrees.m

- compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927

- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"std"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian
    kernel.

fac (int): Rescale kernel bandwidth. Defaults to `1`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>d_hat (np.ndarray): N x 1 vector of the degree at each point in data of size N

s_hat (np.ndarray): N x 1 vector of the sparsity at each point,
    `s_hat=np.divide(1, d_hat)`

sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">degrees</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/degrees.m</span>

<span class="sd">        - compute degree and sparsity estimates of data   https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>
<span class="sd">        </span>
<span class="sd">        - `a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;std&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        fac (int): Rescale kernel bandwidth. Defaults to `1`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        d_hat (np.ndarray): N x 1 vector of the degree at each point in data of size N</span>

<span class="sd">        s_hat (np.ndarray): N x 1 vector of the sparsity at each point, </span>
<span class="sd">            `s_hat=np.divide(1, d_hat)`</span>
<span class="sd">        </span>
<span class="sd">        sigma (np.ndarray): Nx1 (adaptive) or scalar (constant) estiamted kernel bandwidth</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">validate_sigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="n">fac</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
    <span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">d_hat</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">s_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">sigma</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">degrees</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([1., 1., 1., 1., 1.]), array([1., 1., 1., 1., 1.]), 3.7416573867739413)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="local_covariance" class="doc_header"><code>local_covariance</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L240" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>local_covariance</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/local_covariance.m

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"std"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>local_cov (np.ndarray):  N-length cell of local covariance matrices of the Gaussian
    generated noise.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">local_covariance</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/local_covariance.m</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;std&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        local_cov (np.ndarray):  N-length cell of local covariance matrices of the Gaussian</span>
<span class="sd">            generated noise. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">local_cov</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">neigh</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">neigh</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">local_cov</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">local_cov</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data1</span><span class="p">,</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]]),
 array([[[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]]]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data2</span><span class="p">,</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[0., 1., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]]),
 array([[[ 2.5 , -0.75,  2.5 ,  2.5 ,  2.5 ],
         [-0.75,  2.5 , -0.75, -0.75, -0.75],
         [ 2.5 , -0.75,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 , -0.75,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 , -0.75,  2.5 ,  2.5 ,  2.5 ]],
 
        [[ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ]],
 
        [[ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ]],
 
        [[ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ]],
 
        [[ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ],
         [ 2.5 ,  2.5 ,  2.5 ,  2.5 ,  2.5 ]]]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="feature_scale" class="doc_header"><code>feature_scale</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L277" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>feature_scale</code>(<strong><code>x</code></strong>:<code>ndarray</code>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">feature_scale</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fp</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="numpts" class="doc_header"><code>numpts</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L282" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>numpts</code>(<strong><code>degree</code></strong>:<code>ndarray</code>, <strong><code>noise_cov</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>ndarray</code>]=<em><code>1</code></em>, <strong><code>kernel_sigma</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>ndarray</code>]=<em><code>1</code></em>, <strong><code>dim</code></strong>:<code>Union</code>[<code>int</code>, Literal[None]<code>\]=*</code>None<code>*, **</code>M<code>**:</code>int<code>=*</code>0<code>*, **</code>equalize<code>**:</code>bool<code>=*</code>False<code>*, **</code>suppress<code>**:</code>bool<code>=*</code>False<code>*, **</code>logger<code>**:</code>Optional<code>\[</code>Logger<code>\]=*</code>None`*)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/numpts.m

- compute the number of new points to generate around each point in a
    dataset https://arxiv.org/abs/1802.04927

- `M` (number of points to generate)
    + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`
        will negatively impact density equalization, `M &lt;&lt; N` is not recommended
        and `M &lt;&lt;&lt; N` may fail.

    + `not M and equalize`: then density equalization will not be scaled.

    + `M and not equalize`: then approximately `M` points will be generated
        according to a constant difference of max density.

    + `not M and not equalize`: then `M` is approximately N points.

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>degree (np.ndarray): Degree estimate of the N x D data in shape N x 1.


noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation.
    Accepts a scalar for a unifrom Gaussian noise variance or an array
    containing D x D local covariance matricies for Gaussian generated noise.
    Defaults to `1`.

kernel_sigma (int|float|np.ndarray): Degree estimate bandwith. A scalar for uniform
    bandwidth or an N x 1 array for adaptive bandwidth. Defaults to `1`.

dim (int): Generated noise dimension. Defaults to `D` if availible from
    `noise_cov` else required.

M (int): Number of points to generate. Can affect strength of density equalization.
    Can accept positive scalars. Defaults to `0`.

equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults
    to `False`.

suppress (bool): Enabled / disable point generation errors. Defaults to `False`.
    Deprecated.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>npts (np.ndarray): The number of points to generate at each point</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">numpts</span><span class="p">(</span>
    <span class="n">degree</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">noise_cov</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">kernel_sigma</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">dim</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">suppress</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/numpts.m</span>

<span class="sd">        - compute the number of new points to generate around each point in a </span>
<span class="sd">            dataset https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `M` (number of points to generate)</span>
<span class="sd">            + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`</span>
<span class="sd">                will negatively impact density equalization, `M &lt;&lt; N` is not recommended</span>
<span class="sd">                and `M &lt;&lt;&lt; N` may fail.</span>

<span class="sd">            + `not M and equalize`: then density equalization will not be scaled.</span>
<span class="sd">            </span>
<span class="sd">            + `M and not equalize`: then approximately `M` points will be generated</span>
<span class="sd">                according to a constant difference of max density.</span>
<span class="sd">            </span>
<span class="sd">            + `not M and not equalize`: then `M` is approximately N points.</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        degree (np.ndarray): Degree estimate of the N x D data in shape N x 1.</span>


<span class="sd">        noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation. </span>
<span class="sd">            Accepts a scalar for a unifrom Gaussian noise variance or an array </span>
<span class="sd">            containing D x D local covariance matricies for Gaussian generated noise.</span>
<span class="sd">            Defaults to `1`.</span>
<span class="sd">        </span>
<span class="sd">        kernel_sigma (int|float|np.ndarray): Degree estimate bandwith. A scalar for uniform</span>
<span class="sd">            bandwidth or an N x 1 array for adaptive bandwidth. Defaults to `1`.</span>
<span class="sd">        </span>
<span class="sd">        dim (int): Generated noise dimension. Defaults to `D` if availible from </span>
<span class="sd">            `noise_cov` else required. </span>

<span class="sd">        M (int): Number of points to generate. Can affect strength of density equalization.</span>
<span class="sd">            Can accept positive scalars. Defaults to `0`.</span>

<span class="sd">        equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults</span>
<span class="sd">            to `False`.</span>

<span class="sd">        suppress (bool): Enabled / disable point generation errors. Defaults to `False`.</span>
<span class="sd">            Deprecated.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        npts (np.ndarray): The number of points to generate at each point</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">number_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">equalize</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Density equalizaton according to scalar noise covariance...&#39;</span><span class="p">)</span>
            <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="o">-</span> <span class="n">degree</span><span class="p">)</span> <span class="o">*</span> \
                <span class="p">(</span> <span class="p">(</span><span class="n">kernel_sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">noise_cov</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">noise_cov</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Density equalizaton according to local noise covariance...&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">kernel_sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">kernel_sigma</span>
                <span class="n">number_estimate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="o">-</span> <span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span> <span class="c1"># NOTE: &lt;--- this will be a scalar</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> \
                            <span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> 
                    <span class="p">),</span>
                    <span class="mf">0.5</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Applying total generation constraint M.&#39;</span><span class="p">)</span>
            <span class="n">number_save</span> <span class="o">=</span> <span class="n">number_estimate</span>
            <span class="n">number_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">M</span> <span class="o">/</span> <span class="n">number_sum</span> <span class="o">&lt;</span> <span class="mf">1e-1</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">M</span> <span class="o">/</span> <span class="n">number_sum</span> <span class="o">*</span> <span class="mi">100</span><span class="si">}</span><span class="s1">% of equalized total. &#39;</span>
                    <span class="s1">&#39;Output will reflecct equalization. Increased M suggested.&#39;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">number_estimate</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-17</span><span class="p">)</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating without density equalization&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No M supplied, M = N&#39;</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="o">-</span> <span class="n">degree</span><span class="p">)</span>
        <span class="n">number_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">number_estimate</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e17</span><span class="p">)</span>

        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_estimate</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Point generation estimate &lt; 0, either provide/increase M or decrease noise_cov.&#39;</span><span class="p">)</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Point generation estimate &gt; 1e4, either provide/decrease M or increase noise_cov.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">npts</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate" class="doc_header"><code>generate</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L401" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>npts</code></strong>:<code>ndarray</code>, <strong><code>noise_cov</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, <code>ndarray</code>], <strong><code>labels</code></strong>:<code>list</code>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/generate.m

- compute the number of new points to generate around each point in a
    dataset https://arxiv.org/abs/1802.04927

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


npts (np.ndarray): Number of points to generate around each point in data,
    with shape N x 1.

noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation.
    Accepts a scalar for a unifrom Gaussian noise variance or an array
    containing D x D local covariance matricies for Gaussian generated noise.

labels (list): Labels to add to new points

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>random_points (np.ndarray): Noisy generated points with shape `np.sum(npts) x D`.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">generate</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">npts</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">noise_cov</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
    <span class="n">labels</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/generate.m</span>

<span class="sd">        - compute the number of new points to generate around each point in a </span>
<span class="sd">            dataset https://arxiv.org/abs/1802.04927</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        npts (np.ndarray): Number of points to generate around each point in data,</span>
<span class="sd">            with shape N x 1.</span>
<span class="sd">           </span>
<span class="sd">        noise_cov (int|float|np.ndarray): Noise bandwidth used for downstream data generation. </span>
<span class="sd">            Accepts a scalar for a unifrom Gaussian noise variance or an array </span>
<span class="sd">            containing D x D local covariance matricies for Gaussian generated noise.</span>
<span class="sd">                    </span>
<span class="sd">        labels (list): Labels to add to new points</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        random_points (np.ndarray): Noisy generated points with shape `np.sum(npts) x D`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    

    <span class="n">rep_centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rep_cov</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">labels_out</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span> <span class="c1"># constant cov, no need to replicate cov.</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Constant covariance, no need to replicate covariance&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="c1"># replicate data[i] to make npts[i] centers for mvnrnd</span>
            <span class="n">new_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">rep_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_center</span><span class="p">)</span><span class="c1"># = [rep_centers, new_center]</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">new_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">labels_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_out</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">]</span>
        <span class="c1"># generate</span>
        <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
            <span class="n">rep_centers</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">noise_cov</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="c1"># replicate centers npts[i] times</span>
            <span class="n">new_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="c1"># new_center = np.matlib.repmat(row.T, 1, int(npts[i]))</span>
            
            <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">new_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">labels_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_out</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">]</span>
            
            <span class="c1"># rep_centers = [rep_centers, new_center]</span>
            <span class="n">rep_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_center</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># replicate the covariance matrix     </span>
                <span class="n">rep_cov</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">npts</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> 
                                  
                <span class="c1"># if i == 0:</span>
                <span class="c1">#     rep_cov = np.tile(noise_cov[i], (1, 1, npts[i]))                      </span>
                <span class="c1"># else:</span>
                <span class="c1">#     rep_cov = np.concatenate(</span>
                <span class="c1">#         (</span>
                <span class="c1">#             rep_cov,</span>
                <span class="c1">#             np.tile(noise_cov[i], (1, 1, npts[i]))</span>
                <span class="c1">#         ),</span>
                <span class="c1">#         axis=2                    </span>
                <span class="c1">#     )        </span>

        <span class="n">rep_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rep_cov</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">noise_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rep_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rep_centers</span><span class="p">)</span>


        <span class="n">random_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># for i, row in enumerate(rep_centers.T):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rep_centers</span><span class="p">):</span>
            <span class="n">random_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">rep_cov</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="c1"># random_points = np.apply_along_axis(</span>
        <span class="c1">#     np.random.multivariate_normal, 0, </span>
        <span class="c1">#     np.array(rep_centers, dtype=object).T, rep_cov</span>
        <span class="c1"># ) </span>
        <span class="c1"># random_points = np.random.multivariate_normal(</span>
        <span class="c1">#     np.array(rep_centers, dtype=object).T, rep_cov</span>
        <span class="c1"># )</span>
        <span class="c1"># random_points = np.random.Generator.multivariate_normal(</span>
        <span class="c1">#     np.array(rep_centers, dtype=object).T, rep_cov</span>
        <span class="c1"># )</span>
        <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">random_points</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">random_points</span><span class="p">,</span> <span class="n">labels_out</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="magic" class="doc_header"><code>magic</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L509" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>magic</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>kernel</code></strong>:<code>ndarray</code>, <strong><code>t</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>rescale</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/magic.m

- MAGIC (Markov Affinity based Gaussian Imputation of Cells) see:
    + https://www.biorxiv.org/content/early/2017/02/25/111591
    + https://arxiv.org/abs/1802.04927

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.


kernel (np.ndarray): N x N kernel or affinity matrix.

t (int): Time steps to apply MAGIC for. Controls low pass filter cutoff.
    Defaults to `1`.

rescale (bool): Rescale 95th percentile of imputed data to match original
    data. Defaults to `True`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>data_imputed (np.ndarray): M x D Data points imputed via MAGIC using kernel.

diffusion_operator (np.ndarray): M x M Markov matrix built from kernel.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">magic</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">kernel</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">t</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rescale</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/magic.m</span>

<span class="sd">        - MAGIC (Markov Affinity based Gaussian Imputation of Cells) see:</span>
<span class="sd">            + https://www.biorxiv.org/content/early/2017/02/25/111591</span>
<span class="sd">            + https://arxiv.org/abs/1802.04927</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>


<span class="sd">        kernel (np.ndarray): N x N kernel or affinity matrix.</span>
<span class="sd">           </span>
<span class="sd">        t (int): Time steps to apply MAGIC for. Controls low pass filter cutoff.</span>
<span class="sd">            Defaults to `1`.</span>
<span class="sd">                    </span>
<span class="sd">        rescale (bool): Rescale 95th percentile of imputed data to match original</span>
<span class="sd">            data. Defaults to `True`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        data_imputed (np.ndarray): M x D Data points imputed via MAGIC using kernel.</span>

<span class="sd">        diffusion_operator (np.ndarray): M x M Markov matrix built from kernel.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Data does not match kernel size&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="c1"># build diffusion operator</span>
    <span class="n">diffusion_degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span> 
    <span class="n">diffusion_degree</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">diffusion_degree</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">diffusion_operator</span> <span class="o">=</span> <span class="n">diffusion_degree</span> <span class="o">@</span> <span class="n">kernel</span>

    <span class="n">data_imputed</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="c1"># data_imputed = diffusion_operator * data_imputed</span>
        <span class="n">data_imputed</span> <span class="o">=</span> <span class="n">diffusion_operator</span> <span class="o">@</span> <span class="n">data_imputed</span>
    
    <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
        <span class="c1"># NOTE: Heuristic by David to fix vanishing norm when multiplying by diffusion operator</span>
        <span class="n">data_imputed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
            <span class="n">data_imputed</span><span class="p">,</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">95</span><span class="p">),</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data_imputed</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">data_imputed</span><span class="p">,</span> <span class="n">diffusion_operator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="mgc_magic" class="doc_header"><code>mgc_magic</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L577" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>mgc_magic</code>(<strong><code>X</code></strong>:<code>ndarray</code>, <strong><code>Y</code></strong>:<code>ndarray</code>, <strong><code>s_hat</code></strong>:<code>ndarray</code>, <strong><code>sigma</code></strong>:<code>~SigmaType</code>=<em><code>'knn'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>5</code></em>, <strong><code>a</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>fac</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>t</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>magic_rescale</code></strong>:<code>bool</code>=<em><code>1</code></em>, <strong><code>logger</code></strong>:<code>Optional</code>[<code>Logger</code>]=<em><code>None</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/mgc_magic.m

- MGC_MAGIC (Measure-based Gaussian Correlation Kernel w/ MAGIC):
    + https://arxiv.org/abs/1802.04927

- `sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

- `t`
    + `t=0`: [`mgc_magic`](/sugar/core.html#mgc_magic) is not called
    + `t&gt;0`: applies [`mgc_magic`](/sugar/core.html#mgc_magic) steps of diffusion.

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>X (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

Y (np.ndarray): M x D Data matrix. N rows are measurements, D columns are features.

s_hat (np.ndarray): M x 1 measure vector. M entries correspond to measures on the rows of Y.

sigma (str | Callable): The type of sigma function to use or a user defined function.
    Valid `sigma` values include `"minmax"`, `"median"`, `"std"`, `"knn"`. Defaults to
    `"std"`.

k (int): K-nearest neighbor distance to use if `sigma="knn"`. Defaults to `5`.

a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian
    kernel.

fac (int): Rescale kernel bandwidth. Defaults to `1`.

t (int): Apply MGC MAGIC to diffuse new points. If less than `0` [`mgc_magic`](/sugar/core.html#mgc_magic)
    is not called. Defaults to `1`.

magic_rescale (bool): Rescale 95th percentile of imputed data to match original
    data. Defaults to `True`.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>new_data (np.ndarray): M x D New points corrected using MGC MAGIC through X.

mgc_kernel (np.ndarray): M x M MGC kernel built over Y through X via `s_hat`.

mgc_diffusion_operator (np.ndarray): M x M row stochastic MGC
    markov matrix / diffusion operator</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">mgc_magic</span><span class="p">(</span>
    <span class="n">X</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">Y</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">s_hat</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">sigma</span><span class="p">:</span><span class="n">SigmaType</span> <span class="o">=</span> <span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">fac</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/mgc_magic.m</span>

<span class="sd">        - MGC_MAGIC (Measure-based Gaussian Correlation Kernel w/ MAGIC): </span>
<span class="sd">            + https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">        - `a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">        - `t`</span>
<span class="sd">            + `t=0`: `mgc_magic` is not called</span>
<span class="sd">            + `t&gt;0`: applies `mgc_magic` steps of diffusion. </span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        X (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>
<span class="sd">        </span>
<span class="sd">        Y (np.ndarray): M x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        s_hat (np.ndarray): M x 1 measure vector. M entries correspond to measures on the rows of Y.</span>

<span class="sd">        sigma (str | Callable): The type of sigma function to use or a user defined function. </span>
<span class="sd">            Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to </span>
<span class="sd">            `&quot;std&quot;`.</span>

<span class="sd">        k (int): K-nearest neighbor distance to use if `sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        fac (int): Rescale kernel bandwidth. Defaults to `1`.</span>

<span class="sd">        t (int): Apply MGC MAGIC to diffuse new points. If less than `0` `mgc_magic`</span>
<span class="sd">            is not called. Defaults to `1`.</span>
<span class="sd">                    </span>
<span class="sd">        magic_rescale (bool): Rescale 95th percentile of imputed data to match original</span>
<span class="sd">            data. Defaults to `True`.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        new_data (np.ndarray): M x D New points corrected using MGC MAGIC through X.</span>

<span class="sd">        mgc_kernel (np.ndarray): M x M MGC kernel built over Y through X via `s_hat`.</span>

<span class="sd">        mgc_diffusion_operator (np.ndarray): M x M row stochastic MGC </span>
<span class="sd">            markov matrix / diffusion operator</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">Y</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;mgc_magic was passed t=0, no mgc_magic was performed&#39;</span><span class="p">)</span>
    <span class="n">new_to_old</span><span class="p">,</span> <span class="n">sigma_nto</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fac</span><span class="p">)</span>
    <span class="n">old_to_new</span><span class="p">,</span> <span class="n">sigma_otn</span> <span class="o">=</span> <span class="n">gauss_kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fac</span><span class="p">)</span>


    <span class="n">new_to_old_sparsity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_to_old_sparsity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">new_to_old</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">)</span>
    <span class="c1"># new_to_old_sparsity = np.matmul(new_to_old, s_hat)</span>


    <span class="c1"># NOTE: from matlab this is matrix multiply</span>
    <span class="c1"># mgc_kernel = new_to_old_sparsity * old_to_new</span>
    <span class="n">mgc_kernel</span> <span class="o">=</span> <span class="n">new_to_old_sparsity</span> <span class="o">@</span> <span class="n">old_to_new</span>
    <span class="n">mgc_kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span> <span class="p">(</span><span class="n">mgc_kernel</span> <span class="o">+</span> <span class="n">mgc_kernel</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">new_data</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="n">magic</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">magic_rescale</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="sugar" class="doc_header"><code>sugar</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L669" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>sugar</code>(<strong><code>data</code></strong>:<code>ndarray</code>, <strong><code>labels</code></strong>:<code>list</code>=<em><code>[]</code></em>, <strong><code>noise_cov</code></strong>:<code>Union</code>[<code>int</code>, <code>float</code>, Literal['knn']<code>\]=*</code>'knn'<code>*, **</code>noise_k<code>**:</code>int<code>=*</code>5<code>*, **</code>sparsity_idx<code>**:</code>list<code>=*</code>[]<code>*, **</code>degree_sigma<code>**:</code>~SigmaType<code>=*</code>'std'<code>*, **</code>degree_k<code>**:</code>int<code>=*</code>5<code>*, **</code>degree_a<code>**:</code>int<code>=*</code>2<code>*, **</code>degree_fac<code>**:</code>int<code>=*</code>1<code>*, **</code>M<code>**:</code>int<code>=*</code>0<code>*, **</code>equalize<code>**:</code>bool<code>=*</code>False<code>*, **</code>mgc_t<code>**:</code>int<code>=*</code>1<code>*, **</code>mgc_sigma<code>**:</code>~SigmaType<code>=*</code>'knn'<code>*, **</code>mgc_k<code>**:</code>int<code>=*</code>5<code>*, **</code>mgc_a<code>**:</code>int<code>=*</code>2<code>*, **</code>mgc_fac<code>**:</code>int<code>=*</code>1<code>*, **</code>magic_rescale<code>**:</code>bool<code>=*</code>1<code>*, **</code>suppress<code>**:</code>bool<code>=*</code>False<code>*, **</code>logger<code>**:</code>Optional<code>\[</code>Logger<code>\]=*</code>None`*)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/sugar.m

- SUGAR (Geometry-based Data Generation)
    + https://arxiv.org/abs/1802.04927

- `degree_sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `degree_a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

- `M` (number of points to generate)
    + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`
        will negatively impact density equalization, `M &lt;&lt; N` is not recommended
        and `M &lt;&lt;&lt; N` may fail.

    + `not M and equalize`: then density equalization will not be scaled.

    + `M and not equalize`: then approximately `M` points will be generated
        according to a constant difference of max density.

    + `not M and not equalize`: then `M` is approximately N points.

- `mgc_t`
    + `mgc_t=0`: [`mgc_magic`](/sugar/core.html#mgc_magic) is not called
    + `mgc_t&gt;0`: applies [`mgc_magic`](/sugar/core.html#mgc_magic) steps of diffusion.

- `mgc_sigma` (Gaussian kernel bandwidth)
    + `"std"`: standard deviation of the distances
    + `"knn"`: adaptive bandwidth, eg kth neighbor distance
    + `"minmax"`: min-max on the distance matrix
    + `"median"`: the median of the distances
    + `callable`: a function, f, such that f(d) returns a scalar or N-length vector
        where d is an NxN distance matrix
    + `scalar`: pre-computed bandwidth

- `mgc_a` (Alpha kernel decay)
    + `a=2` is Gaussian kernel

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.

labels (list): N x 1 vector of classifier labels. Defaults to `[]`.

noise_cov (int|float|str): Bandwidth of Gaussian noise. Either scalar or `"knn"`.
    Defaults to `"knn"`.

noise_k (int): Neighborhood size for covariance estimation. Defaults to `5`.

sparsity_idx (list): Column indexes for sparsity estimation dimensions. If `[]`
    estimate sparsity in all dimensions. Defaults to `[]`.

degree_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to
    use or a user defined function. Valid `sigma` values include `"minmax"`, `"median"`,
    `"std"`, `"knn"`. Defaults to `"knn"`.

degree_k (int): K-nearest neighbor distance to use if `degree_sigma="knn"`. Defaults to `5`.

degree_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `degree_a=2` is the
    Gaussian kernel.

degree_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.

M (int): Number of points to generate. Can affect strength of density equalization.
    Can accept positive scalars. Defaults to `0`.

equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults
    to `False`.

mgc_t (int): Apply MGC MAGIC to diffuse new points. If less than `0` [`mgc_magic`](/sugar/core.html#mgc_magic)
    is not called. Defaults to `1`.

mgc_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to
    use or a user defined function. Valid `sigma` values include `"minmax"`, `"median"`,
    `"std"`, `"knn"`. Defaults to `"knn"`.

mgc_k (int): K-nearest neighbor distance to use if `mgc_sigma="knn"`. Defaults to `5`.

mgc_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `mgc_a=2` is the Gaussian
    kernel.

mgc_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.

magic_rescale (bool): Rescale 95th percentile of imputed data to match original
    data after MAGIC. Defaults to `True`.

suppress (bool): Enabled / disable point generation errors. Defaults to `False`.
    Deprecated.

logger (logging.Logger): The logger to which to log to. Defaults to `None`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>Y (np.ndarray): M x D New points generated by SUGAR.

out_labels (np.ndarray): M x 1 New labels corresponding to `Y`.

d_hat (np.ndarray): N x 1 Degree estimate of data.

s_hat (np.ndarray): N x 1 Sparsity estimate of data.

sigma (np.ndarray): N x 1 or Scalar sigma used for `d_hat` computation.

noise (np.ndarray): N x D x D of local covariance matrices on `X`.

npts (np.ndarray): N x 1 number of points generated for each point in `X`.

random_points (np.ndarray): M x D random points generated around X.

mgc_kernel (np.ndarray): M x M kernel matrix of `Y` through data over `s_hat`.

mgc_diffusion_operator (np.ndarray): M x M markov matrix of `mgc_kernel`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">sugar</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">labels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">noise_cov</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;knn&quot;</span><span class="p">]]</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">noise_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">sparsity_idx</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">degree_sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">degree_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">degree_a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">degree_fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mgc_t</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">mgc_sigma</span><span class="p">:</span><span class="n">SigmaType</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">mgc_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">mgc_a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">mgc_fac</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">suppress</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes:</span>
<span class="sd">    ---------</span>
<span class="sd">        - Adapted from https://github.com/KrishnaswamyLab/SUGAR/blob/master/matlab/sugar.m</span>

<span class="sd">        - SUGAR (Geometry-based Data Generation)    </span>
<span class="sd">            + https://arxiv.org/abs/1802.04927</span>

<span class="sd">        - `degree_sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">        - `degree_a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">        - `M` (number of points to generate)</span>
<span class="sd">            + `M and equalize`: then density equalization will be scaled by `M`. `M &lt; N`</span>
<span class="sd">                will negatively impact density equalization, `M &lt;&lt; N` is not recommended</span>
<span class="sd">                and `M &lt;&lt;&lt; N` may fail.</span>

<span class="sd">            + `not M and equalize`: then density equalization will not be scaled.</span>
<span class="sd">            </span>
<span class="sd">            + `M and not equalize`: then approximately `M` points will be generated</span>
<span class="sd">                according to a constant difference of max density.</span>
<span class="sd">            </span>
<span class="sd">            + `not M and not equalize`: then `M` is approximately N points.</span>

<span class="sd">        - `mgc_t`</span>
<span class="sd">            + `mgc_t=0`: `mgc_magic` is not called</span>
<span class="sd">            + `mgc_t&gt;0`: applies `mgc_magic` steps of diffusion. </span>

<span class="sd">        - `mgc_sigma` (Gaussian kernel bandwidth)</span>
<span class="sd">            + `&quot;std&quot;`: standard deviation of the distances</span>
<span class="sd">            + `&quot;knn&quot;`: adaptive bandwidth, eg kth neighbor distance</span>
<span class="sd">            + `&quot;minmax&quot;`: min-max on the distance matrix</span>
<span class="sd">            + `&quot;median&quot;`: the median of the distances</span>
<span class="sd">            + `callable`: a function, f, such that f(d) returns a scalar or N-length vector</span>
<span class="sd">                where d is an NxN distance matrix</span>
<span class="sd">            + `scalar`: pre-computed bandwidth</span>

<span class="sd">        - `mgc_a` (Alpha kernel decay)</span>
<span class="sd">            + `a=2` is Gaussian kernel</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        data (np.ndarray): N x D Data matrix. N rows are measurements, D columns are features.</span>

<span class="sd">        labels (list): N x 1 vector of classifier labels. Defaults to `[]`.</span>
<span class="sd">        </span>
<span class="sd">        noise_cov (int|float|str): Bandwidth of Gaussian noise. Either scalar or `&quot;knn&quot;`.</span>
<span class="sd">            Defaults to `&quot;knn&quot;`.</span>
<span class="sd">        </span>
<span class="sd">        noise_k (int): Neighborhood size for covariance estimation. Defaults to `5`.</span>

<span class="sd">        sparsity_idx (list): Column indexes for sparsity estimation dimensions. If `[]`</span>
<span class="sd">            estimate sparsity in all dimensions. Defaults to `[]`.</span>

<span class="sd">        degree_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to </span>
<span class="sd">            use or a user defined function. Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, </span>
<span class="sd">            `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to `&quot;knn&quot;`.</span>

<span class="sd">        degree_k (int): K-nearest neighbor distance to use if `degree_sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        degree_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `degree_a=2` is the </span>
<span class="sd">            Gaussian kernel.</span>
<span class="sd">        </span>
<span class="sd">        degree_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.</span>
<span class="sd">     </span>
<span class="sd">        M (int): Number of points to generate. Can affect strength of density equalization.</span>
<span class="sd">            Can accept positive scalars. Defaults to `0`.</span>

<span class="sd">        equalize (bool): Density equalization. Can be affected by `M` (see notes). Defaults</span>
<span class="sd">            to `False`.</span>

<span class="sd">        mgc_t (int): Apply MGC MAGIC to diffuse new points. If less than `0` `mgc_magic`</span>
<span class="sd">            is not called. Defaults to `1`.</span>

<span class="sd">        mgc_sigma (str | Callable): Diffusion kernel bandwith. The type of sigma function to </span>
<span class="sd">            use or a user defined function. Valid `sigma` values include `&quot;minmax&quot;`, `&quot;median&quot;`, </span>
<span class="sd">            `&quot;std&quot;`, `&quot;knn&quot;`. Defaults to `&quot;knn&quot;`.</span>

<span class="sd">        mgc_k (int): K-nearest neighbor distance to use if `mgc_sigma=&quot;knn&quot;`. Defaults to `5`.</span>

<span class="sd">        mgc_a (int): Alpha-kernel decay parameter. Defaults to `1`. Note `mgc_a=2` is the Gaussian</span>
<span class="sd">            kernel.</span>

<span class="sd">        mgc_fac (int): Rescale mgc kernel bandwidth. Defaults to `1`.</span>
<span class="sd">                    </span>
<span class="sd">        magic_rescale (bool): Rescale 95th percentile of imputed data to match original</span>
<span class="sd">            data after MAGIC. Defaults to `True`.</span>

<span class="sd">        suppress (bool): Enabled / disable point generation errors. Defaults to `False`.</span>
<span class="sd">            Deprecated.</span>

<span class="sd">        logger (logging.Logger): The logger to which to log to. Defaults to `None`.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        Y (np.ndarray): M x D New points generated by SUGAR.</span>

<span class="sd">        out_labels (np.ndarray): M x 1 New labels corresponding to `Y`.</span>

<span class="sd">        d_hat (np.ndarray): N x 1 Degree estimate of data.</span>

<span class="sd">        s_hat (np.ndarray): N x 1 Sparsity estimate of data.</span>

<span class="sd">        sigma (np.ndarray): N x 1 or Scalar sigma used for `d_hat` computation.</span>

<span class="sd">        noise (np.ndarray): N x D x D of local covariance matrices on `X`.</span>

<span class="sd">        npts (np.ndarray): N x 1 number of points generated for each point in `X`.</span>

<span class="sd">        random_points (np.ndarray): M x D random points generated around X.</span>

<span class="sd">        mgc_kernel (np.ndarray): M x M kernel matrix of `Y` through data over `s_hat`.</span>

<span class="sd">        mgc_diffusion_operator (np.ndarray): M x M markov matrix of `mgc_kernel`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Initializing SUGAR&#39;</span><span class="p">)</span>
    <span class="c1"># [data, params] = init(data, varagin{:})</span>

    <span class="n">dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Obtaining Degree Estimate&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sparsity_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">degree_sigma</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">degree_sigma</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">degree_k</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">degree_a</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="n">degree_fac</span><span class="p">,</span>
        <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;d_hat: </span><span class="si">{</span><span class="n">d_hat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;s_hat: </span><span class="si">{</span><span class="n">s_hat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;degree_sigma: </span><span class="si">{</span><span class="n">degree_sigma</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">noise_cov</span> <span class="o">==</span> <span class="s1">&#39;knn&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Local Covariance estimation&#39;</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">local_covariance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">noise_k</span><span class="p">)</span>
        <span class="n">noise_cov</span> <span class="o">=</span> <span class="n">noise</span>
    
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Estimating number of points to generate&#39;</span><span class="p">)</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">numpts</span><span class="p">(</span>
        <span class="n">d_hat</span><span class="p">,</span> <span class="n">noise_cov</span><span class="o">=</span><span class="n">noise_cov</span><span class="p">,</span> <span class="n">kernel_sigma</span><span class="o">=</span><span class="n">degree_sigma</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span>
        <span class="n">equalize</span><span class="o">=</span><span class="n">equalize</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="n">suppress</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating points&#39;</span><span class="p">)</span>
    <span class="n">random_points</span><span class="p">,</span> <span class="n">out_labels</span> <span class="o">=</span> <span class="n">generate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">noise_cov</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">mgc_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Diffusing points via MGC Magic&#39;</span><span class="p">)</span>
        <span class="n">Y</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="n">mgc_magic</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">random_points</span><span class="p">,</span> 
            <span class="n">s_hat</span><span class="o">=</span><span class="n">s_hat</span><span class="p">,</span>  <span class="n">sigma</span><span class="o">=</span><span class="n">mgc_sigma</span><span class="p">,</span> 
            <span class="n">a</span><span class="o">=</span><span class="n">mgc_a</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">mgc_k</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">mgc_t</span><span class="p">,</span>
            <span class="n">fac</span><span class="o">=</span><span class="n">mgc_fac</span><span class="p">,</span> <span class="n">magic_rescale</span><span class="o">=</span><span class="n">magic_rescale</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
        <span class="p">)</span>
        <span class="k">pass</span>
    <span class="c1"># NOTE: (@Jay) assumed that this was there for debugging purposes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">random_points</span>
        <span class="n">mgc_kernel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">Y</span><span class="p">,</span> <span class="n">out_labels</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">random_points</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate_imbalanced_circle" class="doc_header"><code>generate_imbalanced_circle</code><a href="https://github.com/dsm-72/sugar/tree/main/sugar/core.py#L870" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate_imbalanced_circle</code>(<strong><code>n_points</code></strong>:<code>int</code>=<em><code>100</code></em>, <strong><code>n_total</code></strong>:<code>int</code>=<em><code>10000</code></em>, <strong><code>weight</code></strong>:<code>float</code>=<em><code>1.2</code></em>)</p>
</blockquote>
<h2 id="Arugments:">Arugments:<a class="anchor-link" href="#Arugments:"> </a></h2>
<pre><code>n_points (int): number of points to sample from unit circle. Defaults to `100`.

n_total (int): number of points to generate uniformly on the unit circle. Defaults ot `10000`.

weight (float): weight modifier for how much to emphasize the x coordinate on the unit circle.
    Defaults to `1.2`. Setting this to `1` results in almost no points on the lefthand side of
    the circle. Setting it to `2` results in a more uniform balance.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>points (np.ndarray): 2 X `n_points` array of the points on the unit circle.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="k">def</span> <span class="nf">generate_imbalanced_circle</span><span class="p">(</span>
    <span class="n">n_points</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_total</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> 
    <span class="n">weight</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">1.2</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Arugments:</span>
<span class="sd">    ----------</span>
<span class="sd">        n_points (int): number of points to sample from unit circle. Defaults to `100`.</span>

<span class="sd">        n_total (int): number of points to generate uniformly on the unit circle. Defaults ot `10000`.</span>
<span class="sd">        </span>
<span class="sd">        weight (float): weight modifier for how much to emphasize the x coordinate on the unit circle.</span>
<span class="sd">            Defaults to `1.2`. Setting this to `1` results in almost no points on the lefthand side of </span>
<span class="sd">            the circle. Setting it to `2` results in a more uniform balance.</span>

<span class="sd">    Returns:</span>
<span class="sd">    ----------</span>
<span class="sd">        points (np.ndarray): 2 X `n_points` array of the points on the unit circle.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_total</span><span class="p">),</span> <span class="p">))</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">pnts</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span>
        <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
            <span class="n">weights</span><span class="o">=</span><span class="n">weight</span><span class="o">+</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> 
            <span class="n">k</span><span class="o">=</span><span class="n">n_points</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">pnts</span>

<span class="n">pnts</span> <span class="o">=</span> <span class="n">generate_imbalanced_circle</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pnts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pnts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&lt;matplotlib.collections.PathCollection at 0x7f9bb5696c10&gt;</pre>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pnts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;points.csv&#39;</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">Y</span><span class="p">,</span> <span class="n">out_labels</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">random_points</span><span class="p">,</span> <span class="n">mgc_kernel</span><span class="p">,</span> <span class="n">mgc_diffusion_operator</span> <span class="o">=</span> <span class="n">sugar</span><span class="p">(</span>
    <span class="n">pnts</span><span class="p">,</span> 
    <span class="n">labels</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">noise_cov</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">noise_k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">sparsity_idx</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">degree_sigma</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">degree_k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">degree_a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">degree_fac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mgc_t</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">mgc_sigma</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">mgc_k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">mgc_a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">mgc_fac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&lt;matplotlib.collections.PathCollection at 0x7f150213ceb0&gt;</pre>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sugar</span><span class="p">(</span>
    <span class="n">data1</span><span class="p">,</span> 
    <span class="n">labels</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">noise_cov</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">noise_k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">sparsity_idx</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">degree_sigma</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span>
    <span class="n">degree_k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">degree_a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">degree_fac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">equalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mgc_t</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">mgc_sigma</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span>
    <span class="n">mgc_k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">mgc_a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">mgc_fac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">magic_rescale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([[ 2.81244708,  4.97545187,  5.46951769,  5.22013447,  7.38313928],
        [13.02672673, 15.19989926, 18.01348903, 17.98527946, 20.15845202],
        [15.76105145, 17.74560565, 20.67018685, 21.54165199, 23.52620622],
        [16.97004647, 18.82984489, 21.68173858, 22.97411777, 24.83391621],
        [17.20868415, 19.03669175, 21.85251808, 23.22709278, 25.0551004 ]]),
 [],
 array([1., 1., 1., 1., 1.]),
 array([1., 1., 1., 1., 1.]),
 &#39;knn&#39;,
 array([[[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]],
 
        [[ 2.5 ,  2.25,  0.75, -2.25, -2.5 ],
         [ 2.25,  2.5 ,  1.  , -2.5 , -2.25],
         [ 0.75,  1.  ,  2.5 , -1.  , -0.75],
         [-2.25, -2.5 , -1.  ,  2.5 ,  2.25],
         [-2.5 , -2.25, -0.75,  2.25,  2.5 ]]]),
 array([1., 1., 1., 1., 1.]),
 array([[ 0.4129654 ,  1.99000126,  1.75757714,  2.00999874,  3.58703462],
        [ 5.32609392,  7.46391829,  9.58469084,  6.5360817 ,  8.6739061 ],
        [ 7.69464734,  9.73072425, 13.07725298, 14.26927576, 16.30535269],
        [15.55822714, 17.10671344, 18.71866331, 16.89328656, 18.44177285],
        [17.81206195, 18.35114836, 20.26646451, 25.64885163, 26.18793809]]),
 array([[0.96663997, 0.21898546, 0.04732025, 0.02080023, 0.02949851],
        [0.21898546, 1.23700775, 1.04592958, 0.84771196, 0.72976864],
        [0.04732025, 1.04592958, 1.86799466, 1.93282391, 1.64744889],
        [0.02080023, 0.84771196, 1.93282391, 2.5057728 , 2.30886519],
        [0.02949851, 0.72976864, 1.64744889, 2.30886519, 2.18743629]]),
 array([[0.75327814, 0.17064984, 0.03687548, 0.01620909, 0.02298745],
        [0.05368076, 0.30323251, 0.25639278, 0.20780293, 0.17889102],
        [0.00723383, 0.15989098, 0.28555984, 0.29547027, 0.25184507],
        [0.00273113, 0.1113071 , 0.25378552, 0.32901541, 0.30316085],
        [0.00427328, 0.10571734, 0.23865634, 0.33447187, 0.31688117]]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

